<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuYuhe&#39;s Blog</title>
  <icon>https://liuyuhe666.github.io/icon.png</icon>
  
  <link href="https://liuyuhe666.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuyuhe666.github.io/"/>
  <updated>2025-10-31T13:25:24.344Z</updated>
  <id>https://liuyuhe666.github.io/</id>
  
  <author>
    <name>Liu Yuhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解 RAII</title>
    <link href="https://liuyuhe666.github.io/2025/10/21/%E8%AF%A6%E8%A7%A3-RAII/"/>
    <id>https://liuyuhe666.github.io/2025/10/21/%E8%AF%A6%E8%A7%A3-RAII/</id>
    <published>2025-10-21T16:26:09.000Z</published>
    <updated>2025-10-31T13:25:24.344Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h2 id="什么是-RAII（资源获取即初始化）"><a href="#什么是-RAII（资源获取即初始化）" class="headerlink" title="什么是 RAII（资源获取即初始化）"></a>什么是 RAII（资源获取即初始化）</h2><p>RAII（Resource Acquisition Is Initialization）是一种管理资源的编程惯用法：把“资源的获取”绑定到对象的构造过程，把“资源的释放”绑定到对象的析构过程。<strong>当对象创建时获得资源；当对象生命周期结束（离开作用域）时自动释放资源</strong>。这样利用语言的对象生命周期（特别是 C++ 的确定性析构）来确保资源不会泄漏，并能在异常发生时自动清理。</p><p>核心要点：</p><ul><li>资源（file descriptor、内存、锁、socket、HANDLE、线程等）被封装为类的成员；</li><li>构造函数负责获取&#x2F;初始化资源；</li><li>析构函数负责释放资源（清理、close、unlock、free、join 等）；</li><li>利用作用域（stack-based）和确定性析构来保证异常安全与自动释放。</li></ul><h2 id="为什么-RAII-很重要（优点）"><a href="#为什么-RAII-很重要（优点）" class="headerlink" title="为什么 RAII 很重要（优点）"></a>为什么 RAII 很重要（优点）</h2><ol><li><strong>异常安全</strong>：异常抛出时，自动调用局部对象的析构，资源能被释放，避免泄漏。</li><li><strong>简化代码</strong>：将资源获取&#x2F;释放逻辑集中到类中，使用者只需按局部变量的方式使用。</li><li><strong>可组合</strong>：RAII 对象能作为其他对象的成员，从而组合更复杂的资源管理。</li><li><strong>避免忘记释放</strong>：减少手动调用 <code>close</code>&#x2F;<code>free</code> 的出错机会。</li><li><strong>清晰语义</strong>：资源拥有权（ownership）明确，便于 reasoning 与重构。</li></ol><h2 id="最典型的例子（C-）"><a href="#最典型的例子（C-）" class="headerlink" title="最典型的例子（C++）"></a>最典型的例子（C++）</h2><p>最简单的示例：管理文件指针 <code>FILE*</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileRAII</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FileRAII</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode) &#123;<br>        f_ = std::<span class="hljs-built_in">fopen</span>(path, mode);<br>        <span class="hljs-keyword">if</span> (!f_) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;fopen failed&quot;</span>);<br>    &#125;<br>    ~<span class="hljs-built_in">FileRAII</span>() &#123;<br>        <span class="hljs-keyword">if</span> (f_) std::<span class="hljs-built_in">fclose</span>(f_);<br>    &#125;<br>    <span class="hljs-function">FILE* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f_; &#125;<br>    <span class="hljs-comment">// 禁用拷贝以避免双重关闭</span><br>    <span class="hljs-built_in">FileRAII</span>(<span class="hljs-type">const</span> FileRAII&amp;) = <span class="hljs-keyword">delete</span>;<br>    FileRAII&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> FileRAII&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// 支持移动</span><br>    <span class="hljs-built_in">FileRAII</span>(FileRAII&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">f_</span>(other.f_) &#123; other.f_ = <span class="hljs-literal">nullptr</span>; &#125;<br>    FileRAII&amp; <span class="hljs-keyword">operator</span>=(FileRAII&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">if</span> (f_) std::<span class="hljs-built_in">fclose</span>(f_);<br>            f_ = other.f_;<br>            other.f_ = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    FILE* f_ = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">FileRAII <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 当 foo 返回或抛出异常时，file 的析构会自动 fclose</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见-C-标准库-RAII-类型"><a href="#常见-C-标准库-RAII-类型" class="headerlink" title="常见 C++ 标准库 RAII 类型"></a>常见 C++ 标准库 RAII 类型</h2><ul><li><code>std::unique_ptr&lt;T&gt;</code>：拥有型智能指针，析构时 delete。</li><li><code>std::shared_ptr&lt;T&gt;</code>：共享拥有，最后一个引用析构时释放资源（注意循环引用问题）。</li><li><code>std::lock_guard&lt;Mutex&gt;</code> &#x2F; <code>std::unique_lock&lt;Mutex&gt;</code>：互斥锁的 RAII（自动 unlock）。</li><li><code>std::fstream</code> &#x2F; <code>std::ifstream</code> &#x2F; <code>std::ofstream</code>：文件流，析构时关闭文件。</li><li><code>std::thread</code>（需要注意析构前必须 join 或 detach，否则会调用 std::terminate）。</li></ul><h2 id="异常安全与-RAII-的结合（基本概念）"><a href="#异常安全与-RAII-的结合（基本概念）" class="headerlink" title="异常安全与 RAII 的结合（基本概念）"></a>异常安全与 RAII 的结合（基本概念）</h2><p>RAII 是实现异常安全的重要工具。结合异常安全等级（常用概念）：</p><ul><li><strong>无失败保证 (No-throw guarantee)</strong>：操作不会抛异常（构造&#x2F;析构最好不要抛出）。</li><li><strong>强异常安全（Strong）</strong>：操作要么成功要么回滚到原状态（通常通过拷贝&#x2F;交换实现）。</li><li><strong>基本异常安全（Basic）</strong>：保证不会泄露资源，程序仍处于有效状态，但内部可能部分修改。</li></ul><p>实践中：</p><ul><li><strong>析构函数绝不抛异常</strong>（否则在异常传播时会调用 <code>std::terminate</code>）。析构中发生错误应该吞掉或记录日志，不抛出。</li><li>构造函数可以抛（表示获取资源失败），这是合理的——调用者知道构造失败，资源没有被持有。</li></ul><h2 id="移动语义与-RAII"><a href="#移动语义与-RAII" class="headerlink" title="移动语义与 RAII"></a>移动语义与 RAII</h2><p>在现代 C++ 中，RAII 类型通常是<strong>可移动但不可拷贝</strong>（或禁止不安全的拷贝），以表达资源唯一所有权。例如 <code>std::unique_ptr</code>。实现移动语义时要确保：</p><ul><li>移动后源对象处于可析构的“空”状态（不再拥有资源）。</li><li>目标对象接管资源。<br> 这允许将 RAII 对象放进容器或做返回值优化。</li></ul><h2 id="常见模式与技巧"><a href="#常见模式与技巧" class="headerlink" title="常见模式与技巧"></a>常见模式与技巧</h2><h3 id="1-自定义删除器（custom-deleter）"><a href="#1-自定义删除器（custom-deleter）" class="headerlink" title="1. 自定义删除器（custom deleter）"></a>1. 自定义删除器（custom deleter）</h3><p><code>std::unique_ptr</code> 支持自定义删除器，便于管理非 new&#x2F;delete 的资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FILECloser</span> &#123; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE* f)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">if</span> (f) std::<span class="hljs-built_in">fclose</span>(f); &#125; &#125;;<br><span class="hljs-function">std::unique_ptr&lt;FILE, FILECloser&gt; <span class="hljs-title">filePtr</span><span class="hljs-params">(std::fopen(<span class="hljs-string">&quot;a.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>))</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-lock-guard-unique-lock-管理锁"><a href="#2-lock-guard-unique-lock-管理锁" class="headerlink" title="2. lock_guard &#x2F; unique_lock 管理锁"></a>2. lock_guard &#x2F; unique_lock 管理锁</h3><p>避免手动 <code>mutex.lock()</code> &#x2F; <code>mutex.unlock()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::mutex m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(m)</span></span>; <span class="hljs-comment">// 析构时 unlock</span><br>    <span class="hljs-comment">// 安全</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Scope-exit（在离开作用域执行任意清理）"><a href="#3-Scope-exit（在离开作用域执行任意清理）" class="headerlink" title="3. Scope exit（在离开作用域执行任意清理）"></a>3. Scope exit（在离开作用域执行任意清理）</h3><p>C++17 以前常用自定义 scope guard；C++23 有 <code>std::scope_exit</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;scope&gt;</span></span><br><span class="hljs-keyword">auto</span> guard = std::<span class="hljs-built_in">make_scope_exit</span>([]()&#123; <span class="hljs-comment">/* cleanup */</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-通过成员变量实现组合资源"><a href="#4-通过成员变量实现组合资源" class="headerlink" title="4. 通过成员变量实现组合资源"></a>4. 通过成员变量实现组合资源</h3><p>把多个资源作为类成员，析构时会按成员定义的逆序调用析构，自动释放。</p><h3 id="5-非托管资源（系统句柄）也用-RAII"><a href="#5-非托管资源（系统句柄）也用-RAII" class="headerlink" title="5. 非托管资源（系统句柄）也用 RAII"></a>5. 非托管资源（系统句柄）也用 RAII</h3><p>Windows 的 <code>HANDLE</code>、POSIX 的 fd、sockets、OpenGL 资源等，都应封装成 RAII 类。</p><h2 id="常见陷阱与注意事项"><a href="#常见陷阱与注意事项" class="headerlink" title="常见陷阱与注意事项"></a>常见陷阱与注意事项</h2><ol><li><strong>析构时抛异常</strong>：切忌让析构抛异常。若需要报告错误，记录日志或调用 <code>std::terminate</code> 前可选方案，但通常日志更妥当。</li><li><strong>静态对象的销毁顺序问题（静态析构次序）</strong>：跨翻译单元的静态对象销毁顺序不确定，可能导致访问已销毁对象。解决办法包括：把对象放在函数内的静态变量（Meyers 单例）、或使用 <code>std::shared_ptr</code> 延长寿命。</li><li><strong>std::shared_ptr 循环引用</strong>：导致资源无法释放。用 <code>std::weak_ptr</code> 打破循环。</li><li><strong>std::thread 析构问题</strong>：若线程对象在析构时仍 joinable，会 <code>std::terminate</code>。解决：在析构中 join 或 detach，或在构造中将线程交给 RAII 包装（确保析构会 join）。</li><li><strong>双重释放（double free）</strong>：拷贝会导致两个对象释放同一资源，应删除拷贝或正确实现引用计数。</li><li><strong>资源所有权不清</strong>：使用命名清楚的类型（<code>unique_ptr</code> vs <code>shared_ptr</code>）传达所有权语义。</li><li><strong>性能考虑</strong>：小粒度的 RAII 对象创建&#x2F;销毁很便捷但过度使用会有开销，要根据场景权衡（但通常可忽略）。</li></ol><h2 id="与其他语言对比（帮助掌握概念）"><a href="#与其他语言对比（帮助掌握概念）" class="headerlink" title="与其他语言对比（帮助掌握概念）"></a>与其他语言对比（帮助掌握概念）</h2><ul><li><strong>Rust</strong>：所有权模型+借用检查，是 RAII 的更严格形式（资源在所有者离开作用域时自动释放，编译期保证安全）。</li><li><strong>Java &#x2F; C#</strong>：垃圾回收为主，不保证确定性析构。Java 采用 <code>try-with-resources</code>（<code>AutoCloseable</code>）来实现类似 RAII 的确定性释放。C# 有 <code>using</code> 语句。</li><li><strong>Go</strong>：没有析构机制，常用 <code>defer</code> 在函数返回时释放资源（在语义上和 RAII 有类似效果，但不是基于对象生命周期）。</li><li><strong>Python</strong>：<code>with</code> 语句（上下文管理器）是 RAII 的等价，<code>__enter__</code>&#x2F;<code>__exit__</code> 实现资源获取&#x2F;释放。</li></ul><h2 id="进阶示例：互斥锁与条件资源"><a href="#进阶示例：互斥锁与条件资源" class="headerlink" title="进阶示例：互斥锁与条件资源"></a>进阶示例：互斥锁与条件资源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockRAII</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LockRAII</span><span class="hljs-params">(std::mutex&amp; m)</span> : mtx_(m) &#123;</span> mtx_.<span class="hljs-built_in">lock</span>(); &#125;<br>    ~<span class="hljs-built_in">LockRAII</span>() &#123; mtx_.<span class="hljs-built_in">unlock</span>(); &#125;<br>    <span class="hljs-built_in">LockRAII</span>(<span class="hljs-type">const</span> LockRAII&amp;) = <span class="hljs-keyword">delete</span>;<br>    LockRAII&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LockRAII&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">private</span>:<br>    std::mutex&amp; mtx_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>更常用的就是 <code>std::lock_guard</code>，可避免死锁&#x2F;异常时忘记 unlock。</p><h2 id="实战建议（工程级）"><a href="#实战建议（工程级）" class="headerlink" title="实战建议（工程级）"></a>实战建议（工程级）</h2><ol><li><strong>优先使用标准库的 RAII 类型</strong>（<code>unique_ptr</code>, <code>shared_ptr</code>, <code>lock_guard</code>, <code>fstream</code> 等），若需特殊行为再写自定义。</li><li><strong>资源拥有权尽量单一明确</strong>：prefer unique ownership，只有确实需要共享时才用共享引用。</li><li><strong>析构无异常</strong>：析构函数内部保护所有可能抛出的操作（<code>try</code>&#x2F;<code>catch</code>）并处理错误。</li><li><strong>避免裸指针作为 owning semantics</strong>：裸指针可用于 non-owning 观察者，Ownership 用智能指针或明确的 RAII 类。</li><li><strong>在多线程场景</strong>，确保析构不会导致未 join 的线程或死锁。考虑加入超时或显式的关闭协议。</li><li><strong>对外 API</strong>：如果库函数返回资源，优先返回 RAII 类型，不要暴露裸资源句柄。</li></ol><h2 id="什么时候-RAII-不适用？"><a href="#什么时候-RAII-不适用？" class="headerlink" title="什么时候 RAII 不适用？"></a>什么时候 RAII 不适用？</h2><ul><li>某些语言没有确定性析构（如纯 GC 语言）时，RAII 不能直接工作，但语言通常提供等价机制（如 <code>try-with-resources</code> &#x2F; <code>using</code> &#x2F; <code>with</code> &#x2F; <code>defer</code>）。</li><li>需要延迟释放（非作用域边界）时，可能需要显式释放或使用更灵活的生命周期管理器，但仍可用 RAII 封装释放逻辑并提供 <code>release()</code> 方法。</li></ul><h2 id="常见问题（FAQ）"><a href="#常见问题（FAQ）" class="headerlink" title="常见问题（FAQ）"></a>常见问题（FAQ）</h2><ul><li><strong>RAII 会影响性能吗？</strong><br> 通常开销很小。构造&#x2F;析构的代价与资源操作有关（例如 close、fclose）。在性能关键路径上可以评估，但安全性通常优先。</li><li><strong>析构抛异常怎么办？</strong><br> 不要抛。捕获并记录错误。若必须暴露错误，提供显式 <code>close()</code> 方法让调用者检查错误，并在析构时做最安全的清理（并吞异常或记录）。</li><li><strong>如何设计可重入&#x2F;可复制的 RAII？</strong><br> 如果资源本身是可共享的，设计共享语义（引用计数）或提供复制行为；否则禁用拷贝并提供移动。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>RAII &#x3D; 构造时获取，析构时释放。把资源生命周期与对象生命周期绑定。</li><li>它是 C++ 等语言中实现异常安全与资源自动管理的基石。</li><li>使用 <code>unique_ptr</code>、<code>lock_guard</code>、自定义 RAII 类型可以显著减少资源泄漏与复杂清理逻辑。</li><li>注意析构中不要抛异常，注意静态对象析构顺序、shared_ptr 循环引用、线程 join 等实际问题。</li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h2 id=&quot;什么是-RAII（资源获取即初始化）&quot;&gt;&lt;a href=&quot;#什么是-RAII（资源获取即初始化）&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
        
      
    
    
    
    
    <category term="RAII" scheme="https://liuyuhe666.github.io/tags/RAII/"/>
    
    <category term="C++" scheme="https://liuyuhe666.github.io/tags/C/"/>
    
    <category term="内存管理" scheme="https://liuyuhe666.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【推荐系统】常用的推荐算法</title>
    <link href="https://liuyuhe666.github.io/2025/08/24/%E3%80%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E3%80%91%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    <id>https://liuyuhe666.github.io/2025/08/24/%E3%80%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E3%80%91%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</id>
    <published>2025-08-24T16:48:58.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>推荐系统常用的推荐算法可以分为几个大类，每类算法适用于不同的场景和数据特点。</p><h2 id="基于内容的推荐（Content-Based-Filtering）"><a href="#基于内容的推荐（Content-Based-Filtering）" class="headerlink" title="基于内容的推荐（Content-Based Filtering）"></a>基于内容的推荐（Content-Based Filtering）</h2><p><strong>思想</strong>：根据用户历史行为（浏览、点击、购买过的物品），找到物品的特征向量，再推荐相似的物品。</p><ul><li><strong>常用方法</strong>：<ul><li>TF-IDF、Word2Vec、BERT 等文本特征表示</li><li>余弦相似度、欧几里得距离</li></ul></li><li><strong>优点</strong>：不依赖其他用户，能做个性化推荐</li><li><strong>缺点</strong>：容易“信息茧房”，推荐结果缺乏多样性</li></ul><h2 id="协同过滤推荐（Collaborative-Filtering）"><a href="#协同过滤推荐（Collaborative-Filtering）" class="headerlink" title="协同过滤推荐（Collaborative Filtering）"></a>协同过滤推荐（Collaborative Filtering）</h2><p><strong>思想</strong>：通过用户和用户、物品和物品的交互相似性来推荐。</p><ul><li><strong>基于用户的协同过滤（UserCF）</strong>：找出与用户兴趣相似的其他用户，推荐他们喜欢的物品</li><li><strong>基于物品的协同过滤（ItemCF）</strong>：找出与用户喜欢的物品相似的其他物品，推荐给用户</li><li><strong>优点</strong>：不需要物品特征信息，只依赖用户行为数据</li><li><strong>缺点</strong>：稀疏性问题（冷启动）</li></ul><h2 id="矩阵分解（Matrix-Factorization）"><a href="#矩阵分解（Matrix-Factorization）" class="headerlink" title="矩阵分解（Matrix Factorization）"></a>矩阵分解（Matrix Factorization）</h2><p><strong>思想</strong>：将用户-物品评分矩阵分解为低维隐向量，捕捉潜在的兴趣模式。</p><ul><li><strong>代表方法</strong>：<ul><li>SVD（奇异值分解）</li><li>SVD++（考虑隐式反馈）</li><li>ALS（交替最小二乘法）</li></ul></li><li><strong>优点</strong>：推荐效果比传统协同过滤更好，能处理稀疏性</li><li><strong>缺点</strong>：难以解释，冷启动问题依然存在</li></ul><h2 id="基于深度学习的推荐"><a href="#基于深度学习的推荐" class="headerlink" title="基于深度学习的推荐"></a>基于深度学习的推荐</h2><p><strong>思想</strong>：用深度神经网络建模用户和物品的复杂关系。</p><ul><li><strong>常见模型</strong>：<ul><li><strong>DNN + Embedding</strong>：YouTube DNN 推荐模型</li><li><strong>Wide &amp; Deep</strong>（Google Play 应用推荐）</li><li><strong>DeepFM</strong>（结合因子分解机和 DNN）</li><li><strong>Graph Neural Networks (GNNs)</strong>：捕捉用户-物品图结构</li><li><strong>Transformer 推荐模型</strong>（序列建模，捕捉用户行为序列）</li></ul></li><li><strong>优点</strong>：能建模复杂特征交互，效果强大</li><li><strong>缺点</strong>：训练和推理成本高</li></ul><h2 id="基于知识的推荐（Knowledge-Based）"><a href="#基于知识的推荐（Knowledge-Based）" class="headerlink" title="基于知识的推荐（Knowledge-Based）"></a>基于知识的推荐（Knowledge-Based）</h2><p><strong>思想</strong>：利用显式规则或知识图谱进行推荐。</p><ul><li><strong>方法</strong>：<ul><li>基于规则（if-then）</li><li>基于知识图谱（KGAT、RippleNet 等）</li></ul></li><li><strong>适用场景</strong>：冷启动、需要可解释性时（如金融、医疗推荐）</li></ul><h2 id="混合推荐（Hybrid-Recommender）"><a href="#混合推荐（Hybrid-Recommender）" class="headerlink" title="混合推荐（Hybrid Recommender）"></a>混合推荐（Hybrid Recommender）</h2><p><strong>思想</strong>：结合多种方法，取长补短。</p><ul><li><strong>方式</strong>：<ul><li>线性加权（比如 70% 协同过滤 + 30% 基于内容）</li><li>模型融合（stacking、boosting）</li><li>多阶段推荐（召回 + 粗排 + 精排）</li></ul></li></ul><h2 id="强化学习推荐（RL-based）"><a href="#强化学习推荐（RL-based）" class="headerlink" title="强化学习推荐（RL-based）"></a>强化学习推荐（RL-based）</h2><p><strong>思想</strong>：将推荐视为一个序列决策过程，优化长期收益（用户留存、活跃度）。</p><ul><li><strong>典型方法</strong>：<ul><li>Contextual Bandit（上下文多臂老虎机）</li><li>DQN、Policy Gradient 等 RL 算法</li></ul></li><li><strong>适用场景</strong>：需要优化长期目标而不仅是点击率时</li></ul><h2 id="📚-总结"><a href="#📚-总结" class="headerlink" title="📚 总结"></a>📚 总结</h2><ul><li><strong>小数据场景</strong>：基于内容、协同过滤</li><li><strong>中等规模</strong>：矩阵分解、FM</li><li><strong>大规模工业场景</strong>：深度学习（Wide&amp;Deep、DeepFM、YouTube DNN）、混合推荐</li><li><strong>冷启动&#x2F;可解释性需求</strong>：基于知识的推荐</li><li><strong>长期优化</strong>：强化学习推荐</li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;推荐系统常用的推荐算法可以分为几个大类，每类算法适用于不同的场景和数据特点。&lt;/p&gt;
&lt;h2 id=&quot;基于内容的推荐（Content-Based-Filtering）&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="推荐系统" scheme="https://liuyuhe666.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="推荐算法" scheme="https://liuyuhe666.github.io/tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【产品经理】详细分析 B 端与 C 端的区别</title>
    <link href="https://liuyuhe666.github.io/2025/08/22/%E3%80%90%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E3%80%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-B-%E7%AB%AF%E4%B8%8E-C-%E7%AB%AF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liuyuhe666.github.io/2025/08/22/%E3%80%90%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E3%80%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-B-%E7%AB%AF%E4%B8%8E-C-%E7%AB%AF%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-08-22T11:48:56.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>下面从产品经理视角，把 B 端（面向企业&#x2F;组织）与 C 端（面向大众消费者）的差异讲清楚，并给到可落地的方法与指标框架。</p><h1 id="核心差异一览（抓住“大三角”）"><a href="#核心差异一览（抓住“大三角”）" class="headerlink" title="核心差异一览（抓住“大三角”）"></a>核心差异一览（抓住“大三角”）</h1><ul><li><strong>用户与动机</strong><ul><li>B 端：多角色、层级化（采购&#x2F;老板&#x2F;使用者&#x2F;IT&#x2F;财务），动机是“效率、合规、可控、ROI”。</li><li>C 端：单个体或小群体，动机是“好用&#x2F;好玩&#x2F;便宜&#x2F;体面&#x2F;省心”，情绪和口碑影响大。</li></ul></li><li><strong>决策与获客</strong><ul><li>B 端：销售&#x2F;招投标&#x2F;试点驱动，决策链长（RFP→PoC→试点→合同），强背书与案例。</li><li>C 端：增长驱动（ASO&#x2F;SEO&#x2F;投放&#x2F;社媒&#x2F;裂变），决策链短，A&#x2F;B 快速验证。</li></ul></li><li><strong>交付与成功</strong><ul><li>B 端：实施+培训+集成，变更要“可控可追溯”；续约与扩张（NDR）是生命线。</li><li>C 端：上手快、频迭代、体验拉满；看留存&#x2F;时长&#x2F;转化，营收多为订阅&#x2F;内购&#x2F;广告。</li></ul></li></ul><h1 id="产品方法与流程差异"><a href="#产品方法与流程差异" class="headerlink" title="产品方法与流程差异"></a>产品方法与流程差异</h1><h2 id="1）需求与调研"><a href="#1）需求与调研" class="headerlink" title="1）需求与调研"></a>1）需求与调研</h2><ul><li><strong>B 端</strong><ul><li>方法：现场走访、影子研究（Shadowing）、流程梳理（BPMN&#x2F;SIPOC）、价值流分析（VSM）。</li><li>关注：法规&#x2F;内控要求、角色职责、跨系统流程与数据口径、现有 IT 资产与限制。</li><li>输出版：现状流程图→痛点矩阵（影响×频次）→目标流程与可量化收益（时间、错单率、人效）。</li></ul></li><li><strong>C 端</strong><ul><li>方法：用户画像+场景链路、可用性测试、增长实验（A&#x2F;B、多臂老虎机）。</li><li>关注：动机与情绪、首日&#x2F;次日留存的“aha moment”、转化漏斗、口碑传播点。</li></ul></li></ul><h2 id="2）信息架构与交互"><a href="#2）信息架构与交互" class="headerlink" title="2）信息架构与交互"></a>2）信息架构与交互</h2><ul><li><strong>B 端</strong><ul><li>导航以业务流程与角色为纲；支持<strong>批量操作、可编辑表格、快捷键</strong>；</li><li><strong>权限模型</strong>（组织&#x2F;部门&#x2F;角色&#x2F;数据域）、<strong>审计日志</strong>、<strong>草稿&#x2F;审批&#x2F;回滚</strong>；</li><li>配置化（字段、流程、表单、报表）与<strong>多租户隔离</strong>、<strong>单点登录（SSO）</strong>。</li></ul></li><li><strong>C 端</strong><ul><li>新手引导、空状态设计、渐进暴露；</li><li>视觉一致性、可发现性、情绪化体验（动效&#x2F;反馈），<strong>上手 30 秒内达成核心价值</strong>。</li></ul></li></ul><h2 id="3）集成与技术约束"><a href="#3）集成与技术约束" class="headerlink" title="3）集成与技术约束"></a>3）集成与技术约束</h2><ul><li><strong>B 端</strong>：对接 ERP&#x2F;CRM&#x2F;HR&#x2F;财务、消息总线、主数据（MDM）、数据合规（GDPR&#x2F;本地法）、SLA&#x2F;容灾&#x2F;可观测；版本兼容与迁移工具。</li><li><strong>C 端</strong>：端侧性能与兼容、风控反作弊、内容安全、账号生态、支付渠道与退款体验。</li></ul><h2 id="4）商业与定价"><a href="#4）商业与定价" class="headerlink" title="4）商业与定价"></a>4）商业与定价</h2><ul><li><strong>B 端</strong>：按席位&#x2F;按用量&#x2F;分级套餐&#x2F;私有化；常见<strong>账期回款</strong>、里程碑交付；续费与扩容靠“可见 ROI”。</li><li><strong>C 端</strong>：订阅&#x2F;内购&#x2F;广告&#x2F;一次性买断；更多看客单价×留存构成的 <strong>LTV</strong> 与买量 <strong>CAC</strong> 的关系。</li></ul><h1 id="指标体系（PM-的“仪表盘”）"><a href="#指标体系（PM-的“仪表盘”）" class="headerlink" title="指标体系（PM 的“仪表盘”）"></a>指标体系（PM 的“仪表盘”）</h1><h2 id="C-端常用"><a href="#C-端常用" class="headerlink" title="C 端常用"></a>C 端常用</h2><ul><li>北极星：DAU&#x2F;WAU、次日&#x2F;7 日&#x2F;30 日留存、转化率（激活→下单）、LTV、ARPU、付费渗透、分享率、投诉率。</li><li>关键实验：首屏转化、付费墙文案&#x2F;位置、价格锚点、冷启动时长。</li></ul><h2 id="B-端常用"><a href="#B-端常用" class="headerlink" title="B 端常用"></a>B 端常用</h2><ul><li>渗透与采用：<strong>活跃租户数、活跃席位数、功能采用率、上线时长（从签约到首单&#x2F;首流程）</strong>。</li><li>业务价值：<strong>人效提升（单笔时长↓）、错误率&#x2F;返工率↓、合规通过率↑、库存&#x2F;应收周转改善</strong>。</li><li>续费健康度：<strong>续费率、NDR（净收入留存）、流失原因闭环、NPS</strong>。</li><li>可靠性：<strong>SLA、变更失败率、平均修复时间（MTTR）</strong>。</li></ul><h1 id="路线图与发布节奏"><a href="#路线图与发布节奏" class="headerlink" title="路线图与发布节奏"></a>路线图与发布节奏</h1><ul><li><strong>C 端</strong>：短周期（1–2 周）灰度 + A&#x2F;B，快速试错；看增量是否带来留存&#x2F;营收提升。</li><li><strong>B 端</strong>：季度&#x2F;双月节奏更稳健；<strong>版本说明、培训素材、回滚预案</strong>必备；变更窗口与影响评估（谁、何时、影响多大）。</li></ul><h1 id="团队协作与角色"><a href="#团队协作与角色" class="headerlink" title="团队协作与角色"></a>团队协作与角色</h1><ul><li><strong>B 端 PM</strong> 同步售前&#x2F;实施&#x2F;交付&#x2F;客户成功&#x2F;法务&#x2F;财务&#x2F;渠道；需求管理像“项目经理+产品经理”的混合体。</li><li><strong>C 端 PM</strong> 紧密配合增长&#x2F;内容&#x2F;运营&#x2F;投放&#x2F;品牌；强数据驱动与内容策略协同。</li></ul><h1 id="常见坑与对策（按端区分）"><a href="#常见坑与对策（按端区分）" class="headerlink" title="常见坑与对策（按端区分）"></a>常见坑与对策（按端区分）</h1><h2 id="B-端"><a href="#B-端" class="headerlink" title="B 端"></a>B 端</h2><ol><li><strong>只听老板不听一线</strong> → 同时访谈决策者与一线操作，绘制“权责-痛点热力图”。</li><li><strong>低估变更成本</strong> → 建“变更影响清单”（流程&#x2F;权限&#x2F;报表&#x2F;培训&#x2F;集成），灰度+并行期。</li><li><strong>可配置泛滥</strong> → 以 80&#x2F;20 选择“强约束默认+少量开关”，给<strong>模板与预置最佳实践</strong>。</li><li><strong>价值难证明</strong> → 设计<strong>前后对比仪表盘</strong>（时长、错单、产能），提供 ROI 计算器和案例库。</li></ol><h2 id="C-端"><a href="#C-端" class="headerlink" title="C 端"></a>C 端</h2><ol><li><strong>沉迷功能堆叠</strong> → 用 JTBD 拆“完成任务的最小闭环”，围绕 aha moment 打磨路径。</li><li><strong>只看下载不看留存</strong> → 把首日&#x2F;7 日留存作为一等公民，首屏聚焦核心价值。</li><li><strong>买量跑不通</strong> → 严控 CAC&#x2F;LTV，做价格测试、权益分层与用户分群精细化运营。</li><li><strong>风控滞后</strong> → 早期引入基本反作弊与内容安全基线，避免增长“虚胖”。</li></ol><h1 id="从-0→1-的落地清单"><a href="#从-0→1-的落地清单" class="headerlink" title="从 0→1 的落地清单"></a>从 0→1 的落地清单</h1><ul><li><strong>B 端 8 步</strong>：<br> ① 锁定“价值流”→② 关键岗位影子研究→③ 痛点×影响矩阵→④ 目标流程与指标→<br> ⑤ PoC 范围（≤8 周）→⑥ 成功标准（量化）→⑦ 实施与培训包→⑧ 复盘→标品化。</li><li><strong>C 端 8 步</strong>：<br> ① 定义北极星→② 场景化故事板→③ 最小可行闭环（MVP）→④ 首屏&#x2F;新手引导→<br> ⑤ A&#x2F;B 指标体系→⑥ 渠道试投与归因→⑦ 留存与价格测试→⑧ 增长飞轮（内容&#x2F;社群&#x2F;口碑）。</li></ul><h1 id="一个对照表（速查）"><a href="#一个对照表（速查）" class="headerlink" title="一个对照表（速查）"></a>一个对照表（速查）</h1><table><thead><tr><th>维度</th><th>B 端</th><th>C 端</th></tr></thead><tbody><tr><td>用户</td><td>组织多角色</td><td>个人&#x2F;小群体</td></tr><tr><td>决策</td><td>招采&#x2F;试点&#x2F;合同，链路长</td><td>即时决策，情绪化</td></tr><tr><td>交付</td><td>实施、培训、集成</td><td>自助上手、线上分发</td></tr><tr><td>关键价值</td><td>ROI、合规、稳定</td><td>体验、情绪、性价比</td></tr><tr><td>设计重点</td><td>权限&#x2F;流程&#x2F;批量&#x2F;审计</td><td>引导&#x2F;可发现&#x2F;动效&#x2F;易上手</td></tr><tr><td>增长</td><td>销售驱动、案例背书</td><td>渠道投放、口碑裂变</td></tr><tr><td>指标</td><td>采纳率、NDR、SLA、人效</td><td>留存、转化、LTV、ARPU</td></tr><tr><td>版本策略</td><td>慎变更、可回滚</td><td>快迭代、强实验</td></tr></tbody></table><h1 id="给-PM-的取舍准则（通用）"><a href="#给-PM-的取舍准则（通用）" class="headerlink" title="给 PM 的取舍准则（通用）"></a>给 PM 的取舍准则（通用）</h1><ul><li><strong>以“达到价值的最短路径”为北极星</strong>：B 端是达到业务结果最短路径，C 端是达到用户 aha moment 最短路径。</li><li><strong>可解释性与可控性优先</strong>：B 端尤其要能解释规则&#x2F;权限&#x2F;报表口径；C 端要解释价格与权益。</li><li><strong>数据闭环</strong>：设计之初就定义“如何被量化验证”。</li></ul><h1 id="常见的-B-端产品和-C-端产品"><a href="#常见的-B-端产品和-C-端产品" class="headerlink" title="常见的 B 端产品和 C 端产品"></a>常见的 B 端产品和 C 端产品</h1><h2 id="一、常见-B-端产品（To-B：面向企业-组织）"><a href="#一、常见-B-端产品（To-B：面向企业-组织）" class="headerlink" title="一、常见 B 端产品（To B：面向企业&#x2F;组织）"></a>一、常见 B 端产品（To B：面向企业&#x2F;组织）</h2><h3 id="1-企业管理类"><a href="#1-企业管理类" class="headerlink" title="1. 企业管理类"></a>1. 企业管理类</h3><ul><li><strong>ERP</strong>（企业资源计划）：SAP、Oracle ERP、金蝶、用友</li><li><strong>CRM</strong>（客户关系管理）：Salesforce、Zoho CRM、纷享销客、销售易</li><li><strong>HRM &#x2F; OA</strong>（人力资源与协同办公）：Workday、北森、钉钉、企业微信</li></ul><h3 id="2-协作与沟通"><a href="#2-协作与沟通" class="headerlink" title="2. 协作与沟通"></a>2. 协作与沟通</h3><ul><li><strong>企业即时通讯 &#x2F; 协同办公</strong>：Slack、Teams、钉钉、飞书</li><li><strong>项目管理</strong>：Jira、Trello（企业版）、Teambition、禅道</li></ul><h3 id="3-行业-垂直解决方案"><a href="#3-行业-垂直解决方案" class="headerlink" title="3. 行业&#x2F;垂直解决方案"></a>3. 行业&#x2F;垂直解决方案</h3><ul><li><strong>电商 SaaS</strong>：Shopify Plus、微盟、有赞（商家端）</li><li><strong>供应链与物流</strong>：Manhattan Associates、顺丰企业物流系统、菜鸟供应链</li><li><strong>金融科技</strong>：企业级支付网关（Stripe for Business）、风控反欺诈系统、核心银行系统</li></ul><h3 id="4-基础设施与开发工具"><a href="#4-基础设施与开发工具" class="headerlink" title="4. 基础设施与开发工具"></a>4. 基础设施与开发工具</h3><ul><li><strong>云服务</strong>：AWS、阿里云、Azure、腾讯云</li><li><strong>DevOps &#x2F; CI&#x2F;CD</strong>：GitLab 企业版、Jenkins、Harness</li><li><strong>数据中台 &#x2F; BI</strong>：Tableau、Power BI、帆软 BI、Looker</li></ul><h2 id="二、常见-C-端产品（To-C：面向个人消费者）"><a href="#二、常见-C-端产品（To-C：面向个人消费者）" class="headerlink" title="二、常见 C 端产品（To C：面向个人消费者）"></a>二、常见 C 端产品（To C：面向个人消费者）</h2><h3 id="1-互联网应用"><a href="#1-互联网应用" class="headerlink" title="1. 互联网应用"></a>1. 互联网应用</h3><ul><li><strong>社交与通讯</strong>：微信、QQ、WhatsApp、Messenger、Telegram</li><li><strong>短视频与内容</strong>：抖音、快手、B站、YouTube、TikTok</li><li><strong>音乐与娱乐</strong>：Spotify、Apple Music、网易云音乐、爱奇艺、Netflix</li></ul><h3 id="2-电商与消费"><a href="#2-电商与消费" class="headerlink" title="2. 电商与消费"></a>2. 电商与消费</h3><ul><li><strong>综合电商</strong>：淘宝、京东、拼多多、亚马逊</li><li><strong>本地生活 &#x2F; 外卖</strong>：美团、饿了么、DoorDash、Uber Eats</li><li><strong>二手交易</strong>：闲鱼、转转、eBay</li></ul><h3 id="3-金融与支付"><a href="#3-金融与支付" class="headerlink" title="3. 金融与支付"></a>3. 金融与支付</h3><ul><li><strong>移动支付</strong>：支付宝、微信支付、PayPal、Venmo</li><li><strong>理财投资</strong>：蚂蚁财富、雪球、Robinhood</li></ul><h3 id="4-工具与生活服务"><a href="#4-工具与生活服务" class="headerlink" title="4. 工具与生活服务"></a>4. 工具与生活服务</h3><ul><li><strong>出行</strong>：滴滴出行、Uber、Lyft</li><li><strong>地图导航</strong>：高德地图、百度地图、Google Maps</li><li><strong>效率工具</strong>：印象笔记、石墨文档、Notion、Todoist</li><li><strong>健康运动</strong>：Keep、Fitbit App、Nike Run Club</li></ul><h2 id="三、对照举例（同一公司-ToB-与-ToC-产品）"><a href="#三、对照举例（同一公司-ToB-与-ToC-产品）" class="headerlink" title="三、对照举例（同一公司 ToB 与 ToC 产品）"></a>三、对照举例（同一公司 ToB 与 ToC 产品）</h2><ul><li><strong>阿里巴巴</strong><ul><li>B 端：钉钉、阿里云、零售通</li><li>C 端：淘宝、天猫、支付宝</li></ul></li><li><strong>腾讯</strong><ul><li>B 端：企业微信、腾讯云</li><li>C 端：微信、QQ、王者荣耀</li></ul></li><li><strong>字节跳动</strong><ul><li>B 端：飞书、巨量引擎（广告投放平台）</li><li>C 端：抖音、今日头条、TikTok</li></ul></li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;下面从产品经理视角，把 B 端（面向企业&amp;#x2F;组织）与 C 端（面向大众消费者）的差异讲清楚，并给到可落地的方法与指标框架。&lt;/p&gt;
&lt;h1 id=&quot;核心差异一览（抓住“大三角”）&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="产品经理" scheme="https://liuyuhe666.github.io/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
    <category term="B 端" scheme="https://liuyuhe666.github.io/tags/B-%E7%AB%AF/"/>
    
    <category term="C 端" scheme="https://liuyuhe666.github.io/tags/C-%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java 应用程序生产环境下问题排查</title>
    <link href="https://liuyuhe666.github.io/2025/08/07/Java-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://liuyuhe666.github.io/2025/08/07/Java-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2025-08-07T07:43:27.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>在 Java 应用程序的生产环境中，出现问题（如性能下降、内存泄漏、线程死锁、服务不可用等）时，排查问题需要系统化的方法和工具支持。以下是常见的 <strong>问题排查手段</strong>，按问题类型分类：</p><h2 id="🧭-一、基础排查思路"><a href="#🧭-一、基础排查思路" class="headerlink" title="🧭 一、基础排查思路"></a>🧭 一、基础排查思路</h2><ol><li><strong>日志分析</strong>（首选手段）<ul><li>查看应用日志（如 <code>log4j</code>, <code>logback</code>）</li><li>重点关注 <code>ERROR</code>、<code>WARN</code>、异常堆栈</li><li>使用日志聚合工具如 ELK（Elasticsearch + Logstash + Kibana）、Graylog、Splunk 等</li></ul></li><li><strong>监控系统</strong><ul><li>APM 工具（如：Prometheus + Grafana、Skywalking、Pinpoint、New Relic、Datadog）</li><li>监控内容包括：<ul><li>JVM 状态（内存、GC、线程数）</li><li>请求量、延迟、错误率</li><li>数据库连接、慢 SQL</li></ul></li></ul></li><li><strong>复现场景</strong><ul><li>明确“出问题”的前因后果</li><li>收集用户操作、调用链信息、系统日志、监控数据</li></ul></li></ol><h2 id="🧠-二、常见问题排查手段"><a href="#🧠-二、常见问题排查手段" class="headerlink" title="🧠 二、常见问题排查手段"></a>🧠 二、常见问题排查手段</h2><h3 id="1-CPU-占用高"><a href="#1-CPU-占用高" class="headerlink" title="1. CPU 占用高"></a>1. <strong>CPU 占用高</strong></h3><h4 id="排查工具："><a href="#排查工具：" class="headerlink" title="排查工具："></a>排查工具：</h4><ul><li><code>top</code> &#x2F; <code>htop</code>（Linux）</li><li><code>jstack</code>（抓取线程快照）</li><li><code>jvisualvm</code> &#x2F; <code>Java Mission Control</code>（可视化分析）</li><li><code>perf</code>（高级 Linux 工具）</li></ul><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">top -Hp &lt;pid&gt;  <span class="hljs-comment"># 查看哪个线程占用CPU高</span><br></code></pre></td></tr></table></figure><p>将线程ID转为16进制，结合 <code>jstack</code> 找出对应的 Java 线程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstack &lt;pid&gt; &gt; dump.txt<br><span class="hljs-comment"># 查找对应的 nid=0xNNNN 线程堆栈</span><br></code></pre></td></tr></table></figure><h3 id="2-内存泄漏-OOM"><a href="#2-内存泄漏-OOM" class="headerlink" title="2. 内存泄漏 &#x2F; OOM"></a>2. <strong>内存泄漏 &#x2F; OOM</strong></h3><h4 id="排查工具：-1"><a href="#排查工具：-1" class="headerlink" title="排查工具："></a>排查工具：</h4><ul><li><code>jmap -dump</code> 导出堆内存快照</li><li><code>jhat</code> &#x2F; <code>MAT</code>（Memory Analyzer Tool）分析 <code>.hprof</code></li><li><code>VisualVM</code> 查看实时堆使用</li><li>日志中查找 <code>java.lang.OutOfMemoryError</code></li></ul><h4 id="分析重点："><a href="#分析重点：" class="headerlink" title="分析重点："></a>分析重点：</h4><ul><li>某类对象数量是否异常</li><li>GC频率和Full GC情况</li><li>是否存在缓存、线程池、连接池未释放</li></ul><h3 id="3-线程死锁"><a href="#3-线程死锁" class="headerlink" title="3. 线程死锁"></a>3. <strong>线程死锁</strong></h3><h4 id="排查工具：-2"><a href="#排查工具：-2" class="headerlink" title="排查工具："></a>排查工具：</h4><ul><li><code>jstack</code> 多次抓取线程快照</li><li><code>jconsole</code> &#x2F; <code>visualvm</code> 的线程视图</li><li>查找 <code>Found one Java-level deadlock:</code></li></ul><h3 id="4-数据库慢-阻塞"><a href="#4-数据库慢-阻塞" class="headerlink" title="4. 数据库慢&#x2F;阻塞"></a>4. <strong>数据库慢&#x2F;阻塞</strong></h3><h4 id="排查工具：-3"><a href="#排查工具：-3" class="headerlink" title="排查工具："></a>排查工具：</h4><ul><li>查看连接池状态（如 Druid、HikariCP）</li><li>打开数据库慢查询日志</li><li>使用 APM 追踪 SQL 调用时间</li></ul><h3 id="5-网络-服务不可用"><a href="#5-网络-服务不可用" class="headerlink" title="5. 网络&#x2F;服务不可用"></a>5. <strong>网络&#x2F;服务不可用</strong></h3><h4 id="排查手段："><a href="#排查手段：" class="headerlink" title="排查手段："></a>排查手段：</h4><ul><li><code>curl</code> &#x2F; <code>telnet</code> &#x2F; <code>ping</code> &#x2F; <code>nc</code> 检查端口联通</li><li>检查负载均衡器、Nginx、网关配置</li><li>查看服务注册中心（如 Nacos、Eureka）是否注册成功</li><li>检查防火墙和安全组配置</li></ul><h3 id="6-服务频繁重启-Crash"><a href="#6-服务频繁重启-Crash" class="headerlink" title="6. 服务频繁重启 &#x2F; Crash"></a>6. <strong>服务频繁重启 &#x2F; Crash</strong></h3><h4 id="排查方向："><a href="#排查方向：" class="headerlink" title="排查方向："></a>排查方向：</h4><ul><li>日志是否有异常（OutOfMemoryError、StackOverflow、Signal 11）</li><li>是否被 OOM Killer 杀掉（查看 <code>dmesg</code>）</li><li>容器 &#x2F; Supervisor &#x2F; K8s 的 probe 配置是否异常</li></ul><h3 id="7-GC-频繁-性能差"><a href="#7-GC-频繁-性能差" class="headerlink" title="7. GC 频繁 &#x2F; 性能差"></a>7. <strong>GC 频繁 &#x2F; 性能差</strong></h3><h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><ul><li><code>jstat -gcutil &lt;pid&gt; 1s</code> 实时查看 GC 情况</li><li><code>GC 日志</code> 分析（开启 <code>-Xlog:gc*</code> 或 <code>-verbose:gc</code>）</li></ul><h2 id="🔧-三、常用命令速查"><a href="#🔧-三、常用命令速查" class="headerlink" title="🔧 三、常用命令速查"></a>🔧 三、常用命令速查</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看进程</span><br>ps -ef | grep java<br><br><span class="hljs-comment"># 查看堆信息</span><br>jmap -heap &lt;pid&gt;<br><br><span class="hljs-comment"># 导出堆快照</span><br>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;<br><br><span class="hljs-comment"># 查看线程快照</span><br>jstack &lt;pid&gt; &gt; thread.txt<br><br><span class="hljs-comment"># GC 情况</span><br>jstat -gc &lt;pid&gt; 1s<br><br><span class="hljs-comment"># 远程连接 JMX</span><br>java -Dcom.sun.management.jmxremote ...<br></code></pre></td></tr></table></figure><h2 id="🧰-四、生产环境排查建议"><a href="#🧰-四、生产环境排查建议" class="headerlink" title="🧰 四、生产环境排查建议"></a>🧰 四、生产环境排查建议</h2><table><thead><tr><th>建议项</th><th>描述</th></tr></thead><tbody><tr><td><strong>关闭调试模式</strong></td><td>不应开启 <code>-agentlib:jdwp</code> 等调试端口</td></tr><tr><td><strong>开启日志分级</strong></td><td>区分 debug、info、warn、error</td></tr><tr><td><strong>设定合适的 JVM 参数</strong></td><td><code>-Xms</code>, <code>-Xmx</code>, <code>-XX:+HeapDumpOnOutOfMemoryError</code></td></tr><tr><td><strong>设置健康检查</strong></td><td>容器、K8s、LB 健康探针及时剔除异常节点</td></tr><tr><td><strong>灰度发布与回滚策略</strong></td><td>确保变更可控</td></tr><tr><td><strong>链路追踪系统</strong></td><td>便于定位调用链问题（如 SkyWalking、Zipkin、Jaeger）</td></tr></tbody></table></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;在 Java 应用程序的生产环境中，出现问题（如性能下降、内存泄漏、线程死锁、服务不可用等）时，排查问题需要系统化的方法和工具支持。以下是常见的</summary>
        
      
    
    
    
    
    <category term="Java" scheme="https://liuyuhe666.github.io/tags/Java/"/>
    
    <category term="问题排查" scheme="https://liuyuhe666.github.io/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="生产环境" scheme="https://liuyuhe666.github.io/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Rust 生命周期</title>
    <link href="https://liuyuhe666.github.io/2025/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://liuyuhe666.github.io/2025/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2025-08-05T11:20:20.000Z</published>
    <updated>2025-10-31T13:25:24.344Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="深入理解-Rust-生命周期"><a href="#深入理解-Rust-生命周期" class="headerlink" title="深入理解 Rust 生命周期"></a>深入理解 Rust 生命周期</h1><p>理解 Rust 中的生命周期（Lifetimes）是掌握其所有权系统和编写安全、高效代码的关键。它们<strong>不是实际存在的时间段</strong>，而是 Rust 编译器用来<strong>追踪引用的有效范围</strong>，确保引用不会变成悬垂引用（dangling references）的<strong>静态分析工具</strong>。</p><h2 id="⭐-核心概念：为什么需要生命周期？"><a href="#⭐-核心概念：为什么需要生命周期？" class="headerlink" title="⭐ 核心概念：为什么需要生命周期？"></a>⭐ 核心概念：为什么需要生命周期？</h2><ol><li><p><strong>悬垂引用问题：</strong></p><ul><li>想象一个函数返回了它内部创建的某个值的引用。当函数结束时，该值被销毁（离开作用域），但引用却被返回了。任何使用这个返回引用的地方，实际上都在访问一个已经不存在的内存位置 —— 这就是悬垂引用，会导致未定义行为（崩溃、数据损坏）。</li><li>C&#x2F;C++ 中，这类错误需要开发者自己小心避免，极易出错。Rust 的目标是编译时保证内存安全。</li></ul></li><li><p><strong>编译器的困惑：</strong></p><ul><li>当函数涉及多个引用参数或返回引用时，编译器需要知道这些引用之间的关系。</li><li>例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123; <span class="hljs-comment">// 这个函数无法编译！</span><br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译器看到返回 <code>&amp;str</code>，但它不知道这个返回的引用是来自 <code>x</code> 还是 <code>y</code>。</li><li>更重要的是，它<strong>不知道返回引用的生命周期应该与 <code>x</code> 的生命周期绑定，还是与 <code>y</code> 的生命周期绑定</strong>。没有这个信息，编译器就无法检查调用 <code>longest</code> 后返回的引用是否在使用时仍然有效。</li></ul></li></ul></li></ol><h2 id="⭐-生命周期注解（Lifetime-Annotations）：给编译器线索"><a href="#⭐-生命周期注解（Lifetime-Annotations）：给编译器线索" class="headerlink" title="⭐ 生命周期注解（Lifetime Annotations）：给编译器线索"></a>⭐ 生命周期注解（Lifetime Annotations）：给编译器线索</h2><p>为了解决上述问题，Rust 引入了<strong>生命周期注解</strong>。它们使用撇号 <code>&#39;</code> 后跟一个小写字母（通常从 <code>&#39;a</code> 开始）来表示，例如 <code>&#39;a</code>、<code>&#39;b</code>、<code>&#39;live</code>。</p><ul><li><strong>作用：</strong> 描述<strong>多个引用之间的生命周期关系</strong>。它们向编译器声明：某些引用的存活时间必须满足特定的约束条件。</li><li><strong>位置：</strong> 主要出现在函数&#x2F;方法签名、结构体&#x2F;枚举定义中。</li><li><strong>不改变实际生命周期：</strong> 它们<strong>不改变</strong>任何值或引用实际存活的时间。它们只是为编译器提供执行借用检查所需的约束规则。</li><li><strong>语法：</strong> 放在引用符号 <code>&amp;</code> 后面，用空格隔开。<ul><li>引用类型：<code>&amp;&#39;a i32</code>（不可变引用），<code>&amp;&#39;a mut i32</code>（可变引用）</li><li>包含引用的结构体：<code>struct ImportantExcerpt&lt;&#39;a&gt; &#123; part: &amp;&#39;a str &#125;</code></li></ul></li></ul><h2 id="⭐-修正-longest-函数"><a href="#⭐-修正-longest-函数" class="headerlink" title="⭐ 修正 longest 函数"></a>⭐ 修正 <code>longest</code> 函数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>&lt;&#39;a&gt;</code>:</strong> 在函数名后声明一个<strong>生命周期参数</strong> <code>&#39;a</code>。</li><li><strong><code>x: &amp;&#39;a str</code>, <code>y: &amp;&#39;a str</code>:</strong> 参数 <code>x</code> 和 <code>y</code> 都是字符串切片引用，并且它们<strong>至少</strong>存活生命周期 <code>&#39;a</code> 那么长。</li><li><strong><code>-&gt; &amp;&#39;a str</code>:</strong> 返回的字符串切片引用<strong>也</strong>存活生命周期 <code>&#39;a</code> 那么长。</li><li><strong>关键约束：</strong> 这个签名告诉编译器：“函数 <code>longest</code> 返回的引用，其有效范围不会超过传入的两个引用 <code>x</code> 和 <code>y</code> 中较短的那个的生命周期”。编译器会用实际传入引用的具体生命周期来替换 <code>&#39;a</code>，并验证这个约束是否满足。</li></ul><h2 id="⭐-生命周期省略规则（Lifetime-Elision-Rules）"><a href="#⭐-生命周期省略规则（Lifetime-Elision-Rules）" class="headerlink" title="⭐ 生命周期省略规则（Lifetime Elision Rules）"></a>⭐ 生命周期省略规则（Lifetime Elision Rules）</h2><p>Rust 团队发现某些模式非常常见，因此制定了规则，允许开发者在这些情况下<strong>省略</strong>显式的生命周期注解。编译器会自动推断。</p><p>三条规则（按顺序应用）：</p><ol><li><strong>每个引用参数获得自己的生命周期参数。</strong><ul><li><code>fn foo(x: &amp;i32)</code> -&gt; <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code></li><li><code>fn bar(x: &amp;i32, y: &amp;i32)</code> -&gt; <code>fn bar&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code></li></ul></li><li><strong>如果只有一个输入生命周期参数，它被赋给所有输出生命周期参数。</strong><ul><li><code>fn foo(x: &amp;i32) -&gt; &amp;i32</code> -&gt; <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code></li></ul></li><li><strong>如果有多个输入生命周期参数，但其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>（即方法），则 <code>self</code> 的生命周期被赋给所有省略的输出生命周期参数。</strong><ul><li>这是让方法可读性更高的关键规则。</li><li><code>impl SomeStruct &#123; fn method(&amp;self, x: &amp;i32) -&gt; &amp;i32 &#123; ... &#125; &#125;</code> -&gt; <code>fn method&lt;&#39;a, &#39;b&gt;(&amp;&#39;a self, x: &amp;&#39;b i32) -&gt; &amp;&#39;a i32</code></li></ul></li></ol><p><strong>重要：</strong> 如果应用这三条规则后，输出引用的生命周期仍然不明确，编译器就会报错，要求你显式添加注解。</p><h2 id="⭐-结构体中的生命周期"><a href="#⭐-结构体中的生命周期" class="headerlink" title="⭐ 结构体中的生命周期"></a>⭐ 结构体中的生命周期</h2><p>当结构体的字段包含引用时，<strong>必须</strong>在结构体名称后声明生命周期参数，并在每个引用字段中使用它。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcerpt</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, <span class="hljs-comment">// 表示结构体实例不能比其字段 `part` 所引用的数据存活得更久</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">novel</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Call me Ishmael. Some years ago...&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first_sentence</span> = novel.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = ImportantExcerpt &#123;<br>        part: first_sentence,<br>    &#125;; <span class="hljs-comment">// `i` 的生命周期不能超过 `first_sentence`，而 `first_sentence` 是 `novel` 的切片，所以也不能超过 `novel`</span><br>    <span class="hljs-comment">// `novel` 在这里必须保持有效</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⭐-方法中的生命周期"><a href="#⭐-方法中的生命周期" class="headerlink" title="⭐ 方法中的生命周期"></a>⭐ 方法中的生命周期</h2><p>在 <code>impl</code> 块中定义方法时，需要在 <code>impl</code> 后声明结构体的生命周期参数（如 <code>&lt;&#39;a&gt;</code>），并在方法签名中使用它（如果需要）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// 规则3应用：返回的引用获得与 `&amp;self` 相同的生命周期 `&#x27;a`</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">announce_and_return_part</span>(&amp;<span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>    <span class="hljs-comment">// 返回新字符串，不涉及引用，不需要生命周期注解</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_full_part</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">self</span>.part.<span class="hljs-title function_ invoke__">to_string</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⭐-static-生命周期"><a href="#⭐-static-生命周期" class="headerlink" title="⭐ &#39;static 生命周期"></a>⭐ <code>&#39;static</code> 生命周期</h2><ul><li>表示引用在<strong>整个程序运行期间</strong>都有效。</li><li>最常见的例子：字符串字面量 <code>&quot;hello&quot;</code> 的类型是 <code>&amp;&#39;static str</code>，因为它被硬编码在程序的二进制文件中。</li><li><strong>谨慎使用：</strong> 真正需要 <code>&#39;static</code> 生命周期的情况相对较少。不要用它来解决编译器错误，这通常掩盖了设计问题。</li></ul><h2 id="⭐-生命周期在泛型中的结合"><a href="#⭐-生命周期在泛型中的结合" class="headerlink" title="⭐ 生命周期在泛型中的结合"></a>⭐ 生命周期在泛型中的结合</h2><p>生命周期参数本质上是泛型的一种特殊形式。它们可以与其他泛型类型参数（<code>T</code>）一起使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest_with_an_announcement</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(<br>    x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>    y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>    ann: T, <span class="hljs-comment">// 泛型类型 T</span><br>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span><br><span class="hljs-keyword">where</span><br>    T: std::fmt::Display, <span class="hljs-comment">// T 必须实现 Display trait</span><br>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⭐-深入理解的关键点"><a href="#⭐-深入理解的关键点" class="headerlink" title="⭐ 深入理解的关键点"></a>⭐ 深入理解的关键点</h2><ol><li><strong>编译时概念：</strong> 生命周期只在编译时存在，用于静态分析。运行时没有“生命周期”的额外开销。</li><li><strong>关系描述：</strong> <code>&#39;a: &#39;b</code> 读作 “生命周期 <code>&#39;a</code> <strong>至少</strong>活得和 <code>&#39;b</code> 一样长”（outlives）。它表示 <code>&#39;a</code> 覆盖的范围包含了 <code>&#39;b</code> 覆盖的范围。</li><li><strong>目标：确保有效性：</strong> 生命周期的核心目标是确保<strong>引用在其被使用的整个范围内，它所指向的数据始终是有效的</strong>。编译器强制执行“<strong>引用的生命周期不能超过其引用的数据的生命周期</strong>”这一铁律。</li><li><strong>由借用检查器验证：</strong> Rust 编译器中的借用检查器（borrow checker）利用生命周期注解（或推断出的生命周期）来验证代码是否满足上述安全条件。</li><li><strong>实践驱动：</strong> 初期不必过度思考如何标注。先写代码，遇到编译器关于生命周期的错误时，仔细阅读错误信息（Rust 的错误信息通常非常精准），理解编译器指出的关系，然后根据需要添加注解。随着经验积累，你会逐渐形成直觉。</li></ol><h2 id="⭐-总结"><a href="#⭐-总结" class="headerlink" title="⭐ 总结"></a>⭐ 总结</h2><p>生命周期是 Rust 实现内存安全而无须垃圾收集的核心机制。它们是编译器用来验证引用有效性的静态规则。通过生命周期注解（或依赖省略规则），开发者向编译器描述不同引用之间的存活关系约束。编译器（借用检查器）利用这些约束确保程序在任何路径下都不会出现悬垂引用，从而在编译期就杜绝了一大类内存安全问题。理解生命周期是写出正确、健壮 Rust 代码的必经之路。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;深入理解-Rust-生命周期&quot;&gt;&lt;a href=&quot;#深入理解-Rust-生命周期&quot; class=&quot;headerlink&quot; title=&quot;深入理解 Rust 生命周期&quot;&gt;&lt;/a&gt;深入理解 Rust</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://liuyuhe666.github.io/tags/Rust/"/>
    
    <category term="生命周期" scheme="https://liuyuhe666.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>CAP 理论</title>
    <link href="https://liuyuhe666.github.io/2025/07/30/CAP-%E7%90%86%E8%AE%BA/"/>
    <id>https://liuyuhe666.github.io/2025/07/30/CAP-%E7%90%86%E8%AE%BA/</id>
    <published>2025-07-30T07:27:28.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>CAP 理论（CAP Theorem）是分布式系统中的一个重要概念，由计算机科学家 <strong>Eric Brewer</strong> 在 2000 年提出，后来由 <strong>Seth Gilbert 和 Nancy Lynch</strong> 在 2002 年通过数学证明正式提出。CAP 是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong> 和 <strong>Partition tolerance（分区容错性）</strong> 三个属性的缩写。</p><p>CAP 理论的核心结论是：</p><blockquote><p><strong>在一个分布式系统中，最多只能同时满足 CAP 中的两个属性，而不可能三者兼得。</strong></p></blockquote><h2 id="一、三个属性解释"><a href="#一、三个属性解释" class="headerlink" title="一、三个属性解释"></a>一、三个属性解释</h2><ol><li>一致性（Consistency）</li></ol><ul><li>各个节点的数据在任何时刻都是一致的。</li><li>表现为：客户端无论连接哪个节点，读取到的数据都应该是最新的。</li></ul><p>✅ 举例：类似于传统关系型数据库事务中的强一致性（如 MySQL ACID）。</p><ol start="2"><li>可用性（Availability）</li></ol><ul><li>每个请求都能在有限时间内得到响应（成功或失败都算响应）。</li><li>即使部分节点失效，系统依然能够处理请求并返回结果。</li></ul><p>✅ 举例：如果你请求一个服务，它即使不能保证返回最新数据，也必须返回一个响应（不能超时挂死）。</p><ol start="3"><li>分区容错性（Partition Tolerance）</li></ol><ul><li>系统在发生网络分区（Partition，即部分节点之间通信中断）时，仍能继续提供服务。</li><li>网络分区是分布式系统中不可避免的，如服务器宕机、链路断裂、网络延迟等。</li></ul><p>✅ 举例：两个数据中心之间断网，系统仍然运行，不完全崩溃。</p><h2 id="二、CAP-不可同时满足三者"><a href="#二、CAP-不可同时满足三者" class="headerlink" title="二、CAP 不可同时满足三者"></a>二、CAP 不可同时满足三者</h2><p>当系统发生网络分区时（这是现实中无法完全避免的），我们只能 <strong>在一致性（C）和可用性（A）中选择一个</strong>。</p><table><thead><tr><th>选择</th><th>意味着放弃</th></tr></thead><tbody><tr><td>C + P</td><td>放弃可用性：可能拒绝部分请求以保持一致性（如强一致）</td></tr><tr><td>A + P</td><td>放弃一致性：仍然响应请求，但不同节点间数据可能暂时不一致</td></tr><tr><td>C + A</td><td>不可能实现：无法容忍网络分区（现实中难以避免）</td></tr></tbody></table><h2 id="三、CAP-理论在实际系统中的体现"><a href="#三、CAP-理论在实际系统中的体现" class="headerlink" title="三、CAP 理论在实际系统中的体现"></a>三、CAP 理论在实际系统中的体现</h2><p>常见分布式系统选择：</p><table><thead><tr><th>系统</th><th>类型</th><th>取舍（CAP）</th></tr></thead><tbody><tr><td><strong>Zookeeper</strong></td><td>协调服务</td><td>CP：保证一致性，网络分区时可能不可用</td></tr><tr><td><strong>Etcd</strong></td><td>配置中心</td><td>CP：追求一致性，可能牺牲可用性</td></tr><tr><td><strong>MongoDB（默认配置）</strong></td><td>NoSQL数据库</td><td>AP：牺牲强一致性，确保可用性</td></tr><tr><td><strong>Cassandra</strong></td><td>NoSQL数据库</td><td>AP：高可用，但数据一致性需要特殊设计</td></tr><tr><td><strong>Redis（集群模式）</strong></td><td>缓存系统</td><td>AP：更注重响应速度和可用性</td></tr><tr><td><strong>HBase</strong></td><td>大数据存储</td><td>CP：追求强一致性</td></tr></tbody></table><h2 id="四、与-BASE-理论对比"><a href="#四、与-BASE-理论对比" class="headerlink" title="四、与 BASE 理论对比"></a>四、与 BASE 理论对比</h2><p>CAP 通常用于解释系统设计上的权衡，而 BASE 理论是对 CAP 中“牺牲强一致性”策略的具体实践，尤其在大型互联网系统中常用：</p><table><thead><tr><th>BASE 属性</th><th>含义</th></tr></thead><tbody><tr><td>Basically Available</td><td>基本可用，允许系统部分失效但整体可用</td></tr><tr><td>Soft state</td><td>允许中间状态存在，状态并非强一致</td></tr><tr><td>Eventual consistency</td><td>最终一致性，系统最终会达到一致状态</td></tr></tbody></table><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>CAP 理论不是一个设计标准，而是一个现实制约。</strong></li><li>系统不能同时满足 C、A、P，必须根据业务需求权衡取舍。</li><li>对于强事务、金融系统：倾向 <strong>CP</strong></li><li>对于高可用、低延迟系统：倾向 <strong>AP</strong></li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;CAP 理论（CAP Theorem）是分布式系统中的一个重要概念，由计算机科学家 &lt;strong&gt;Eric Brewer&lt;/strong&gt; 在 2000 年提出，后来由 &lt;strong&gt;Seth Gilbert</summary>
        
      
    
    
    
    
    <category term="分布式" scheme="https://liuyuhe666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="CAP" scheme="https://liuyuhe666.github.io/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>HeavyKeeper 算法</title>
    <link href="https://liuyuhe666.github.io/2025/07/21/HeavyKeeper-%E7%AE%97%E6%B3%95/"/>
    <id>https://liuyuhe666.github.io/2025/07/21/HeavyKeeper-%E7%AE%97%E6%B3%95/</id>
    <published>2025-07-21T14:54:06.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>HeavyKeeper 是一种用于在数据流中<strong>高效检测重频元素（Heavy Hitters）<strong>的概率算法。它适合处理</strong>高速、高频、内存受限场景</strong>，如网络流量监控、日志分析、推荐系统等。</p><h2 id="📌-核心目标"><a href="#📌-核心目标" class="headerlink" title="📌 核心目标"></a>📌 核心目标</h2><p>从一个连续到达的数据流中，<strong>估计频率最高的前-K个元素</strong>，在不可能存储所有元素及其精确频率的情况下，HeavyKeeper 提供了一个<strong>近似但效果优秀的方案</strong>。</p><h2 id="🧠-算法原理"><a href="#🧠-算法原理" class="headerlink" title="🧠 算法原理"></a>🧠 算法原理</h2><ol><li>数据结构（类似 Count-Min Sketch）</li></ol><p>HeavyKeeper 使用一个二维数组（通常是 <code>w × d</code>）来保存计数信息，其中：</p><ul><li><code>w</code> 是桶的宽度（列数）</li><li><code>d</code> 是哈希函数数量（行数）</li></ul><p>每个桶保存一个 <code>(item, counter)</code> 对。<br> 每次输入一个元素，通过 <code>d</code> 个哈希函数映射到 <code>d</code> 个桶，每个桶处理一次更新逻辑。</p><ol start="2"><li>更新策略（带有衰减）</li></ol><p>设：</p><ul><li><code>item</code> 是当前元素</li><li><code>counter</code> 是桶中已有的计数值</li><li><code>item_bucket</code> 是桶中的已有元素</li></ul><p>更新步骤：</p><ol><li>对于每个哈希函数 <code>hi</code>：<ul><li>计算哈希位置：<code>pos = hi(item)</code></li><li>如果 <code>item_bucket == item</code>：<ul><li><code>counter++</code></li></ul></li><li>否则：<ul><li>以概率 <code>b^(-counter)</code>（其中 <code>b &gt; 1</code>，如 1.08）进行“衰减”：<ul><li>有可能将当前桶替换为新元素，并把 counter 初始化为 1</li></ul></li></ul></li></ul></li></ol><p>这种<strong>概率衰减机制</strong>允许频繁出现的元素保留它们的位置，偶尔出现的元素容易被踢出</p><h2 id="⏱-查询方式"><a href="#⏱-查询方式" class="headerlink" title="⏱ 查询方式"></a>⏱ 查询方式</h2><p>要查询某个元素的频率估计值，只需通过相同的 <code>d</code> 个哈希函数，找到所有包含该元素的桶的计数值，取其中的<strong>最大值</strong>（或中位数）作为估计值。</p><h2 id="🎯-特点"><a href="#🎯-特点" class="headerlink" title="🎯 特点"></a>🎯 特点</h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>空间效率高</strong></td><td>只需 <code>w × d</code> 大小</td></tr><tr><td><strong>支持删除（可扩展）</strong></td><td>可结合 Time Decay 或 TTL 实现</td></tr><tr><td><strong>误差可控</strong></td><td>高频元素估计误差小，低频元素容易被挤掉</td></tr><tr><td><strong>适合 Top-K 查询</strong></td><td>常与小顶堆结合</td></tr></tbody></table><h2 id="🔧-示例参数"><a href="#🔧-示例参数" class="headerlink" title="🔧 示例参数"></a>🔧 示例参数</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">w = 1000      // 宽度<br>d = 4         // 哈希函数数量<br>b = 1.08      // 衰减基数（&gt; 1）<br></code></pre></td></tr></table></figure><h2 id="🧪-应用示例"><a href="#🧪-应用示例" class="headerlink" title="🧪 应用示例"></a>🧪 应用示例</h2><ul><li><strong>CDN 热门资源监控</strong>：识别最常访问的 URL</li><li><strong>推荐系统</strong>：捕捉用户高频交互物品</li><li><strong>DDoS 检测</strong>：检测访问频率最高的 IP</li><li><strong>日志处理</strong>：找出最频繁的错误代码</li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;HeavyKeeper 是一种用于在数据流中&lt;strong&gt;高效检测重频元素（Heavy</summary>
        
      
    
    
    
    
    <category term="算法" scheme="https://liuyuhe666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="概率" scheme="https://liuyuhe666.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Java 单例模式</title>
    <link href="https://liuyuhe666.github.io/2025/07/12/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liuyuhe666.github.io/2025/07/12/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-07-12T17:38:57.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="Java-单例模式"><a href="#Java-单例模式" class="headerlink" title="Java 单例模式"></a>Java 单例模式</h1><p>Java 中实现单例模式（Singleton Pattern）主要有以下几种方式，每种方式都有各自的优缺点。下面是对常见实现方式的总结和对比：</p><h2 id="🧩-一、饿汉式（Eager-Initialization）"><a href="#🧩-一、饿汉式（Eager-Initialization）" class="headerlink" title="🧩 一、饿汉式（Eager Initialization）"></a>🧩 一、饿汉式（Eager Initialization）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="✅-优点："><a href="#✅-优点：" class="headerlink" title="✅ 优点："></a>✅ 优点：</h3><ul><li>实现简单。</li><li>类加载时即创建实例，线程安全。</li><li>不会出现多线程问题。</li></ul><h3 id="❌-缺点："><a href="#❌-缺点：" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h3><ul><li><strong>资源浪费</strong>：类加载时就实例化，可能实际不需要用到该实例。</li></ul><h2 id="🧊-二、懒汉式（Lazy-Initialization，非线程安全）"><a href="#🧊-二、懒汉式（Lazy-Initialization，非线程安全）" class="headerlink" title="🧊 二、懒汉式（Lazy Initialization，非线程安全）"></a>🧊 二、懒汉式（Lazy Initialization，非线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="✅-优点：-1"><a href="#✅-优点：-1" class="headerlink" title="✅ 优点："></a>✅ 优点：</h3><ul><li>延迟加载：只有在第一次调用时才创建实例。</li></ul><h3 id="❌-缺点：-1"><a href="#❌-缺点：-1" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h3><ul><li><strong>线程不安全</strong>，多线程环境下可能会创建多个实例。</li></ul><h2 id="🧵-三、懒汉式（线程安全，加锁）"><a href="#🧵-三、懒汉式（线程安全，加锁）" class="headerlink" title="🧵 三、懒汉式（线程安全，加锁）"></a>🧵 三、懒汉式（线程安全，加锁）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="✅-优点：-2"><a href="#✅-优点：-2" class="headerlink" title="✅ 优点："></a>✅ 优点：</h3><ul><li>线程安全。</li><li>实现简单。</li></ul><h3 id="❌-缺点：-2"><a href="#❌-缺点：-2" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h3><ul><li><strong>性能低</strong>：每次调用 <code>getInstance()</code> 都要加锁，影响性能。</li></ul><h2 id="💡-四、双重检查锁（Double-Checked-Locking）"><a href="#💡-四、双重检查锁（Double-Checked-Locking）" class="headerlink" title="💡 四、双重检查锁（Double-Checked Locking）"></a>💡 四、双重检查锁（Double-Checked Locking）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="✅-优点：-3"><a href="#✅-优点：-3" class="headerlink" title="✅ 优点："></a>✅ 优点：</h3><ul><li>线程安全。</li><li>性能较好，只在第一次创建实例时加锁。</li></ul><h3 id="❌-缺点：-3"><a href="#❌-缺点：-3" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h3><ul><li>实现复杂，需使用 <code>volatile</code> 防止指令重排。</li></ul><h2 id="🧘-五、静态内部类（推荐方式）"><a href="#🧘-五、静态内部类（推荐方式）" class="headerlink" title="🧘 五、静态内部类（推荐方式）"></a>🧘 五、静态内部类（推荐方式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Holder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="✅-优点：-4"><a href="#✅-优点：-4" class="headerlink" title="✅ 优点："></a>✅ 优点：</h3><ul><li>延迟加载。</li><li>线程安全。</li><li>性能好，无需同步。</li><li>实现简单。</li></ul><h3 id="❌-缺点：-4"><a href="#❌-缺点：-4" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h3><ul><li>无明显缺点，属于推荐方式。</li></ul><h2 id="🔐-六、枚举实现（最安全、最简单）"><a href="#🔐-六、枚举实现（最安全、最简单）" class="headerlink" title="🔐 六、枚举实现（最安全、最简单）"></a>🔐 六、枚举实现（最安全、最简单）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="✅-优点：-5"><a href="#✅-优点：-5" class="headerlink" title="✅ 优点："></a>✅ 优点：</h3><ul><li>天生线程安全。</li><li>防止反射和反序列化攻击。</li><li>简洁优雅。</li></ul><h3 id="❌-缺点：-5"><a href="#❌-缺点：-5" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h3><ul><li><strong>不支持延迟加载</strong>。</li><li>形式上不同于传统类写法，某些场景下不适用（如需要继承）。</li></ul><h2 id="📊-对比总结表："><a href="#📊-对比总结表：" class="headerlink" title="📊 对比总结表："></a>📊 对比总结表：</h2><table><thead><tr><th>实现方式</th><th>线程安全</th><th>是否懒加载</th><th>性能</th><th>是否推荐</th></tr></thead><tbody><tr><td>饿汉式</td><td>✅</td><td>❌</td><td>高</td><td>❌</td></tr><tr><td>懒汉式（非线程）</td><td>❌</td><td>✅</td><td>高</td><td>❌</td></tr><tr><td>懒汉式（同步方法）</td><td>✅</td><td>✅</td><td>低</td><td>❌</td></tr><tr><td>双重检查锁</td><td>✅</td><td>✅</td><td>高</td><td>✅</td></tr><tr><td>静态内部类</td><td>✅</td><td>✅</td><td>高</td><td>✅✅✅</td></tr><tr><td>枚举实现</td><td>✅</td><td>❌</td><td>高</td><td>✅✅✅</td></tr></tbody></table><h2 id="✅-推荐使用："><a href="#✅-推荐使用：" class="headerlink" title="✅ 推荐使用："></a>✅ 推荐使用：</h2><ul><li>如果可以不使用延迟加载 ➤ <strong>枚举方式</strong>（最安全）</li><li>如果需要延迟加载 ➤ <strong>静态内部类方式</strong></li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;Java-单例模式&quot;&gt;&lt;a href=&quot;#Java-单例模式&quot; class=&quot;headerlink&quot; title=&quot;Java 单例模式&quot;&gt;&lt;/a&gt;Java 单例模式&lt;/h1&gt;&lt;p&gt;Java</summary>
        
      
    
    
    
    
    <category term="Java" scheme="https://liuyuhe666.github.io/tags/Java/"/>
    
    <category term="设计模式" scheme="https://liuyuhe666.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派模型</title>
    <link href="https://liuyuhe666.github.io/2025/07/06/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://liuyuhe666.github.io/2025/07/06/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-07-06T14:48:45.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>类加载器的 <strong>双亲委派模型（Parent Delegation Model）</strong> 是 Java 虚拟机中类加载机制的一部分，主要用于保证 Java 平台的安全性和类加载的一致性。</p><h2 id="🧭-一、什么是双亲委派模型？"><a href="#🧭-一、什么是双亲委派模型？" class="headerlink" title="🧭 一、什么是双亲委派模型？"></a>🧭 一、什么是双亲委派模型？</h2><p>双亲委派模型的核心思想是：</p><blockquote><p><strong>一个类加载器在接收到类加载请求时，先把这个请求委托给它的“父类加载器”去完成；只有在父类加载器无法完成这个请求（即找不到类）时，子类加载器才会尝试自己去加载。</strong></p></blockquote><h2 id="🏗️-二、类加载器结构"><a href="#🏗️-二、类加载器结构" class="headerlink" title="🏗️ 二、类加载器结构"></a>🏗️ 二、类加载器结构</h2><p>Java 默认的类加载器结构如下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Bootstrap</span> <span class="hljs-variable">ClassLoader</span> <span class="hljs-punctuation">(</span>启动类加载器<span class="hljs-punctuation">)</span><br>        ↑<br><span class="hljs-built_in">Extension</span> <span class="hljs-variable">ClassLoader</span>（扩展类加载器）<br>        ↑<br><span class="hljs-built_in">Application</span> <span class="hljs-variable">ClassLoader</span>（应用类加载器）<br>        ↑<br><span class="hljs-variable">Custom</span> <span class="hljs-variable">ClassLoader</span>（自定义类加载器）<br></code></pre></td></tr></table></figure><h2 id="🔄-三、类加载过程流程图"><a href="#🔄-三、类加载过程流程图" class="headerlink" title="🔄 三、类加载过程流程图"></a>🔄 三、类加载过程流程图</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">加载某个类 -&gt; 先请求父加载器加载<br>                ↓<br>     父加载器能加载？ → 是 → 使用父加载器加载<br>                      → 否 → 当前加载器自己加载<br></code></pre></td></tr></table></figure><h2 id="📦-四、为什么使用双亲委派模型？"><a href="#📦-四、为什么使用双亲委派模型？" class="headerlink" title="📦 四、为什么使用双亲委派模型？"></a>📦 四、为什么使用双亲委派模型？</h2><ol><li><strong>避免类的重复加载</strong><br> 如果父类已经加载过了某个类，子类加载器就不会再加载，避免了类的冗余和冲突。</li><li><strong>保护核心 API</strong><br> 自定义类无法伪造 <code>java.lang.String</code> 等核心类，因为请求会优先由启动类加载器处理，从而保证了核心类的唯一性和安全性。</li><li><strong>保证类加载的一致性</strong><br> 比如当多个类加载器加载相同类时，双亲委派机制能保证这些类具有相同的版本，避免运行时冲突。</li></ol><h2 id="🔧-五、自定义类加载器如何打破双亲委派（可选）"><a href="#🔧-五、自定义类加载器如何打破双亲委派（可选）" class="headerlink" title="🔧 五、自定义类加载器如何打破双亲委派（可选）"></a>🔧 五、自定义类加载器如何打破双亲委派（可选）</h2><p>某些场景（如热部署、Tomcat、OSGi 插件系统）需要打破双亲委派：</p><ul><li>自定义类加载器可以 <strong>先尝试自己加载</strong>，然后再委托父类（称为**“打破双亲委派”**）。</li><li>常见的方式是重写 <code>loadClass()</code> 方法，不直接调用 <code>super.loadClass()</code>，而是改为先 <code>findClass()</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 不委托父加载器，直接自己找</span><br>    Class&lt;?&gt; c = findClass(name);<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>        resolveClass(c);<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>⚠️ 注意：打破双亲委派机制要非常小心，可能引发类冲突或安全问题。</p><h2 id="📘-六、示例：类加载器加载顺序"><a href="#📘-六、示例：类加载器加载顺序" class="headerlink" title="📘 六、示例：类加载器加载顺序"></a>📘 六、示例：类加载器加载顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> TestClassLoader.class.getClassLoader();<br><br>        <span class="hljs-keyword">while</span> (classLoader != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(classLoader);<br>            classLoader = classLoader.getParent();<br>        &#125;<br>        <span class="hljs-comment">// 最后输出 null，表示 Bootstrap ClassLoader</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出示例（JDK 8）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span>.Launcher<span class="hljs-variable">$AppClassLoader</span><br>sun<span class="hljs-selector-class">.misc</span>.Launcher<span class="hljs-variable">$ExtClassLoader</span><br>null<br></code></pre></td></tr></table></figure><h2 id="✅-七、小结"><a href="#✅-七、小结" class="headerlink" title="✅ 七、小结"></a>✅ 七、小结</h2><table><thead><tr><th>类加载器</th><th>作用</th><th>加载内容</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>核心类加载器（C++实现）</td><td>加载 JDK 的核心类（rt.jar）</td></tr><tr><td>Extension ClassLoader</td><td>Java 扩展类加载器（Java实现）</td><td>加载 <code>jre/lib/ext</code> 下的类</td></tr><tr><td>AppClassLoader</td><td>应用类加载器</td><td>加载应用 classpath 下的类</td></tr><tr><td>自定义 ClassLoader</td><td>用户定义加载器</td><td>加载指定路径或网络类</td></tr></tbody></table></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;类加载器的 &lt;strong&gt;双亲委派模型（Parent Delegation Model）&lt;/strong&gt; 是 Java 虚拟机中类加载机制的一部分，主要用于保证 Java</summary>
        
      
    
    
    
    
    <category term="Java" scheme="https://liuyuhe666.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://liuyuhe666.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 类加载过程</title>
    <link href="https://liuyuhe666.github.io/2025/07/06/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://liuyuhe666.github.io/2025/07/06/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2025-07-06T14:44:27.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h2 id="📖-JVM-类加载过程"><a href="#📖-JVM-类加载过程" class="headerlink" title="📖 JVM 类加载过程"></a>📖 JVM 类加载过程</h2><p>JVM（Java Virtual Machine，Java虚拟机）的类加载过程是Java程序运行的重要组成部分，它负责将 <code>.class</code> 文件加载到内存中，并生成对应的 <code>Class</code> 对象，供程序使用。</p><p>整个类加载过程主要分为以下 <strong>五个阶段</strong>：</p><h3 id="🧩-1-加载（Loading）"><a href="#🧩-1-加载（Loading）" class="headerlink" title="🧩 1. 加载（Loading）"></a>🧩 1. <strong>加载（Loading）</strong></h3><ul><li><strong>作用</strong>：将类的字节码从各种来源（如文件系统、网络）加载到内存中，生成 <code>java.lang.Class</code> 对象。</li><li><strong>来源</strong>：<ul><li>本地文件系统（如 <code>.class</code> 文件）</li><li>jar包</li><li>网络（通过自定义类加载器）</li></ul></li><li><strong>关键点</strong>：<ul><li>使用类加载器完成（系统类加载器、自定义类加载器等）</li><li>字节码文件转为内存中的数据结构（<code>Class</code> 对象）</li></ul></li></ul><h3 id="🔧-2-连接（Linking）"><a href="#🔧-2-连接（Linking）" class="headerlink" title="🔧 2. 连接（Linking）"></a>🔧 2. <strong>连接（Linking）</strong></h3><p>连接阶段包含三个子阶段：</p><h4 id="2-1-验证（Verification）"><a href="#2-1-验证（Verification）" class="headerlink" title="2.1 验证（Verification）"></a>2.1 验证（Verification）</h4><ul><li>确保字节码文件符合JVM规范，保证程序运行安全。</li><li>如校验常量池、字节码格式、类型检查、符号引用等。</li></ul><h4 id="2-2-准备（Preparation）"><a href="#2-2-准备（Preparation）" class="headerlink" title="2.2 准备（Preparation）"></a>2.2 准备（Preparation）</h4><ul><li>为类的 <strong>静态变量</strong> 分配内存，并设置 <strong>默认初始值</strong>（不是代码中的初始值）。<ul><li>例如：<code>static int a = 10;</code> 此时只分配 <code>a = 0</code>。</li></ul></li></ul><h4 id="2-3-解析（Resolution）"><a href="#2-3-解析（Resolution）" class="headerlink" title="2.3 解析（Resolution）"></a>2.3 解析（Resolution）</h4><ul><li>将常量池中的符号引用（Symbolic Reference）转换为直接引用（Direct Reference）。<ul><li>如方法调用、字段访问、类继承等引用的解析。</li></ul></li></ul><h3 id="🚀-3-初始化（Initialization）"><a href="#🚀-3-初始化（Initialization）" class="headerlink" title="🚀 3. 初始化（Initialization）"></a>🚀 3. <strong>初始化（Initialization）</strong></h3><ul><li>执行类的 <strong><code>&lt;clinit&gt;</code> 方法</strong>（静态代码块和静态变量初始化代码）。</li><li>顺序：<ol><li>父类先初始化</li><li>子类再初始化</li></ol></li><li>只有在类 <strong>首次主动使用时</strong> 才进行初始化。</li></ul><h3 id="💡-4-使用（Using）"><a href="#💡-4-使用（Using）" class="headerlink" title="💡 4. 使用（Using）"></a>💡 4. <strong>使用（Using）</strong></h3><ul><li>类已经被加载到 JVM 中，可以正常使用：实例化对象、调用方法、访问字段等。</li></ul><h3 id="🧹-5-卸载（Unloading）"><a href="#🧹-5-卸载（Unloading）" class="headerlink" title="🧹 5. 卸载（Unloading）"></a>🧹 5. <strong>卸载（Unloading）</strong></h3><ul><li>当一个类不再被使用，且对应的 <code>ClassLoader</code> 被回收，则类的 <code>Class</code> 对象会被卸载。</li><li>通常发生在：<ul><li>使用自定义类加载器</li><li>类加载器及其加载的类都没有引用时</li></ul></li><li>注意：<strong>JVM 的启动类加载器加载的类通常不会被卸载</strong>。</li></ul><h2 id="🔄-类加载器体系（ClassLoader）"><a href="#🔄-类加载器体系（ClassLoader）" class="headerlink" title="🔄 类加载器体系（ClassLoader）"></a>🔄 类加载器体系（ClassLoader）</h2><p>Java 中有三种主要的类加载器（JDK 8 及之前）：</p><ol><li><strong>启动类加载器（Bootstrap ClassLoader）</strong><ul><li>加载核心类库（<code>rt.jar</code> 等）</li><li>C++实现，非Java对象</li></ul></li><li><strong>扩展类加载器（Extension ClassLoader）</strong><ul><li>加载 <code>ext</code> 目录下的类库（<code>jre/lib/ext</code>）</li></ul></li><li><strong>应用类加载器（AppClassLoader）</strong><ul><li>加载classpath下的类</li></ul></li></ol><p>此外还有<strong>自定义类加载器</strong>，可用于插件系统、热部署等。</p><h2 id="📌-类的主动使用-vs-被动使用（初始化的触发）"><a href="#📌-类的主动使用-vs-被动使用（初始化的触发）" class="headerlink" title="📌 类的主动使用 vs 被动使用（初始化的触发）"></a>📌 类的主动使用 vs 被动使用（初始化的触发）</h2><h3 id="主动使用（会触发初始化）："><a href="#主动使用（会触发初始化）：" class="headerlink" title="主动使用（会触发初始化）："></a>主动使用（会触发初始化）：</h3><ul><li>创建类的实例</li><li>调用类的静态方法</li><li>访问类的静态变量（非 final）</li><li>使用反射调用类的方法或构造器</li><li>子类初始化时，其父类也会初始化</li></ul><h3 id="被动使用（不会触发初始化）："><a href="#被动使用（不会触发初始化）：" class="headerlink" title="被动使用（不会触发初始化）："></a>被动使用（不会触发初始化）：</h3><ul><li>访问类的 <code>Class</code> 对象：<code>Class clazz = SomeClass.class;</code></li><li>通过数组定义类：<code>SomeClass[] array = new SomeClass[10];</code></li><li>引用常量：<code>System.out.println(SomeClass.CONSTANT);</code>（<code>CONSTANT</code> 是 <code>static final</code> 并且编译期可确定）</li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h2 id=&quot;📖-JVM-类加载过程&quot;&gt;&lt;a href=&quot;#📖-JVM-类加载过程&quot; class=&quot;headerlink&quot; title=&quot;📖 JVM 类加载过程&quot;&gt;&lt;/a&gt;📖 JVM</summary>
        
      
    
    
    
    
    <category term="Java" scheme="https://liuyuhe666.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://liuyuhe666.github.io/tags/JVM/"/>
    
    <category term="类加载" scheme="https://liuyuhe666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Next.js SEO 优化指南</title>
    <link href="https://liuyuhe666.github.io/2025/06/04/Next-js-SEO-%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <id>https://liuyuhe666.github.io/2025/06/04/Next-js-SEO-%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</id>
    <published>2025-06-04T20:22:56.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>在 Next.js 项目中进行 SEO（搜索引擎优化）可以显著提高网页在搜索引擎结果中的排名，提升可见性与访问量。以下是 <strong>Next.js SEO 优化的全面指南</strong>，涵盖技术层面与内容策略：</p><h2 id="🧠-一、基础-SEO-实践"><a href="#🧠-一、基础-SEO-实践" class="headerlink" title="🧠 一、基础 SEO 实践"></a>🧠 一、基础 SEO 实践</h2><h3 id="1-使用-next-head-设置-Meta-标签"><a href="#1-使用-next-head-设置-Meta-标签" class="headerlink" title="1. 使用 next/head 设置 Meta 标签"></a>1. 使用 <code>next/head</code> 设置 Meta 标签</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Head</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/head&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">HomePage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>你的页面标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;页面描述，有助于提升搜索排名&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;关键词1, 关键词2&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:title&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;社交媒体分享标题&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;社交媒体分享描述&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:image&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;/og-image.jpg&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index, follow&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-页面唯一性"><a href="#2-页面唯一性" class="headerlink" title="2. 页面唯一性"></a>2. 页面唯一性</h3><ul><li>每个页面都应有独特的 <code>&lt;title&gt;</code> 和 <code>&lt;meta description&gt;</code>。</li><li>避免复制粘贴模板内容。</li></ul><h2 id="🚀-二、技术层优化"><a href="#🚀-二、技术层优化" class="headerlink" title="🚀 二、技术层优化"></a>🚀 二、技术层优化</h2><h3 id="1-服务端渲染（SSR）或静态生成（SSG）"><a href="#1-服务端渲染（SSR）或静态生成（SSG）" class="headerlink" title="1. 服务端渲染（SSR）或静态生成（SSG）"></a>1. 服务端渲染（SSR）或静态生成（SSG）</h3><p>利用 Next.js 的 <code>getServerSideProps</code> 或 <code>getStaticProps</code> 提供预渲染内容，提高爬虫可读性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchContent</span>()<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123; data &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用-Sitemap-和-robots-txt"><a href="#2-使用-Sitemap-和-robots-txt" class="headerlink" title="2. 使用 Sitemap 和 robots.txt"></a>2. 使用 Sitemap 和 robots.txt</h3><p>安装插件 <a href="https://www.npmjs.com/package/next-sitemap"><code>next-sitemap</code></a> 生成 sitemap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install next-sitemap<br></code></pre></td></tr></table></figure><p>配置 <code>next-sitemap.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">siteUrl</span>: <span class="hljs-string">&#x27;https://yourdomain.com&#x27;</span>,<br>  <span class="hljs-attr">generateRobotsTxt</span>: <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>添加到 <code>package.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;postbuild&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next-sitemap&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-支持多语言-SEO（如需）"><a href="#3-支持多语言-SEO（如需）" class="headerlink" title="3. 支持多语言 SEO（如需）"></a>3. 支持多语言 SEO（如需）</h3><p>使用 Next.js 的 <a href="https://nextjs.org/docs/advanced-features/i18n-routing">国际化路由</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">i18n</span>: &#123;<br>  <span class="hljs-attr">locales</span>: [<span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;zh&#x27;</span>],<br>  <span class="hljs-attr">defaultLocale</span>: <span class="hljs-string">&#x27;zh&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="🖼️-三、结构化数据（Structured-Data）"><a href="#🖼️-三、结构化数据（Structured-Data）" class="headerlink" title="🖼️ 三、结构化数据（Structured Data）"></a>🖼️ 三、结构化数据（Structured Data）</h2><p>添加 JSON-LD 数据以增强 Google 富摘要（Rich Results）：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;<span class="hljs-title class_">Head</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/ld+json&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">__html:</span> <span class="hljs-attr">JSON.stringify</span>(&#123;</span></span><br><span class="hljs-tag"><span class="language-xml">        &quot;@<span class="hljs-attr">context</span>&quot;<span class="hljs-attr">:</span> &quot;<span class="hljs-attr">https:</span>//<span class="hljs-attr">schema.org</span>&quot;,</span></span><br><span class="hljs-tag"><span class="language-xml">        &quot;@<span class="hljs-attr">type</span>&quot;<span class="hljs-attr">:</span> &quot;<span class="hljs-attr">Article</span>&quot;,</span></span><br><span class="hljs-tag"><span class="language-xml">        &quot;<span class="hljs-attr">headline</span>&quot;<span class="hljs-attr">:</span> &quot;<span class="hljs-attr">文章标题</span>&quot;,</span></span><br><span class="hljs-tag"><span class="language-xml">        &quot;<span class="hljs-attr">author</span>&quot;<span class="hljs-attr">:</span> &#123;</span></span><br><span class="hljs-tag"><span class="language-xml">          &quot;@<span class="hljs-attr">type</span>&quot;<span class="hljs-attr">:</span> &quot;<span class="hljs-attr">Person</span>&quot;,</span></span><br><span class="hljs-tag"><span class="language-xml">          &quot;<span class="hljs-attr">name</span>&quot;<span class="hljs-attr">:</span> &quot;<span class="hljs-attr">作者名</span>&quot;</span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;,</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">...</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &#125;),</span></span><br><span class="hljs-tag"><span class="language-xml">    &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><br>&lt;/<span class="hljs-title class_">Head</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="🧰-四、使用第三方库优化-SEO"><a href="#🧰-四、使用第三方库优化-SEO" class="headerlink" title="🧰 四、使用第三方库优化 SEO"></a>🧰 四、使用第三方库优化 SEO</h2><p>推荐库：<a href="https://github.com/garmeeh/next-seo"><code>next-seo</code></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install next-seo<br></code></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NextSeo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next-seo&#x27;</span><br><br>&lt;<span class="hljs-title class_">NextSeo</span><br>  title=<span class="hljs-string">&quot;页面标题&quot;</span><br>  description=<span class="hljs-string">&quot;页面描述&quot;</span><br>  canonical=<span class="hljs-string">&quot;https://yourdomain.com/page&quot;</span><br>  openGraph=&#123;&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://yourdomain.com/page&#x27;</span>,<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;OG标题&#x27;</span>,<br>    <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;OG描述&#x27;</span>,<br>    <span class="hljs-attr">images</span>: [&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/og-image.jpg&#x27;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">600</span> &#125;],<br>  &#125;&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><h2 id="📱-五、提升移动端体验和性能"><a href="#📱-五、提升移动端体验和性能" class="headerlink" title="📱 五、提升移动端体验和性能"></a>📱 五、提升移动端体验和性能</h2><ul><li>✅ 响应式设计（使用 Tailwind CSS、CSS Modules 等）</li><li>✅ 使用 <code>Image</code> 组件优化图片：</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/image&#x27;</span><br><br>&lt;<span class="hljs-title class_">Image</span> src=<span class="hljs-string">&quot;/example.jpg&quot;</span> alt=<span class="hljs-string">&quot;描述&quot;</span> width=&#123;<span class="hljs-number">800</span>&#125; height=&#123;<span class="hljs-number">600</span>&#125; /&gt;<br></code></pre></td></tr></table></figure><ul><li>✅ 使用 <a href="https://pagespeed.web.dev/">Lighthouse</a> 测试性能、可访问性和 SEO 分数。</li></ul><h2 id="📈-六、内容优化建议"><a href="#📈-六、内容优化建议" class="headerlink" title="📈 六、内容优化建议"></a>📈 六、内容优化建议</h2><ul><li>原创内容优先</li><li>使用 H1-H6 正确分层标题</li><li>链接到内部和外部权威页面</li><li>页面 URL 简洁且包含关键词，如：<code>/blog/nextjs-seo</code> 而不是 &#96;&#x2F;blog?id&#x3D;123</li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;在 Next.js 项目中进行 SEO（搜索引擎优化）可以显著提高网页在搜索引擎结果中的排名，提升可见性与访问量。以下是 &lt;strong&gt;Next.js SEO</summary>
        
      
    
    
    
    
    <category term="Next.js" scheme="https://liuyuhe666.github.io/tags/Next-js/"/>
    
    <category term="SEO" scheme="https://liuyuhe666.github.io/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据结构及应用场景总结</title>
    <link href="https://liuyuhe666.github.io/2025/04/28/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://liuyuhe666.github.io/2025/04/28/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/</id>
    <published>2025-04-28T17:52:46.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="Redis-数据结构及应用场景总结"><a href="#Redis-数据结构及应用场景总结" class="headerlink" title="Redis 数据结构及应用场景总结"></a>Redis 数据结构及应用场景总结</h1><p>Redis 支持多种数据结构，每种结构都有其独特的用途和适用场景。以下是 Redis 核心数据结构及其关键特性的总结：</p><h2 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1. String（字符串）"></a><strong>1. String（字符串）</strong></h2><ul><li><strong>底层实现</strong>：简单动态字符串（SDS，Simple Dynamic String），支持二进制安全。</li><li><strong>用途</strong>：<ul><li>缓存文本、数值、二进制数据（如图片）。</li><li>计数器（<code>INCR</code>&#x2F;<code>DECR</code>）。</li><li>分布式锁（<code>SETNX</code>）。</li></ul></li><li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">SET key value<br>GET key<br>INCR counter<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-List（列表）"><a href="#2-List（列表）" class="headerlink" title="2. List（列表）"></a><strong>2. List（列表）</strong></h2><ul><li><strong>底层实现</strong>：<ul><li>早期：<code>ziplist</code>（压缩列表，内存紧凑）和 <code>linkedlist</code>（双向链表）。</li><li>Redis 3.2+：统一为 <strong><code>quicklist</code></strong>（链表 + ziplist 的混合结构）。</li></ul></li><li><strong>用途</strong>：<ul><li>消息队列（<code>LPUSH</code> + <code>BRPOP</code>）。</li><li>最新消息列表（按插入顺序存储）。</li></ul></li><li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">LPUSH list value<br>RPOP list<br>LRANGE list 0 -1<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Hash（哈希表）"><a href="#3-Hash（哈希表）" class="headerlink" title="3. Hash（哈希表）"></a><strong>3. Hash（哈希表）</strong></h2><ul><li><strong>底层实现</strong>：<ul><li><code>ziplist</code>（字段较少时）或 <code>hashtable</code>（默认）。</li></ul></li><li><strong>用途</strong>：<ul><li>存储对象（如用户信息，键对应多个字段）。</li><li>避免序列化开销（可单独修改字段）。</li></ul></li><li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">HSET user:1 name <span class="hljs-string">&quot;Alice&quot;</span><br>HGET user:1 name<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4. Set（集合）"></a><strong>4. Set（集合）</strong></h2><ul><li><strong>底层实现</strong>：<ul><li><code>intset</code>（元素为整数且数量较少时）或 <code>hashtable</code>（元素为字符串）。</li></ul></li><li><strong>用途</strong>：<ul><li>去重存储（如标签、用户关注列表）。</li><li>集合运算（<code>SINTER</code> 交集，<code>SUNION</code> 并集）。</li></ul></li><li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">SADD tags <span class="hljs-string">&quot;redis&quot;</span><br>SMEMBERS tags<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-Sorted-Set（有序集合）"><a href="#5-Sorted-Set（有序集合）" class="headerlink" title="5. Sorted Set（有序集合）"></a><strong>5. Sorted Set（有序集合）</strong></h2><ul><li><strong>底层实现</strong>：<ul><li><code>ziplist</code>（元素较少时）或 <strong><code>跳表（skiplist）</code> + <code>hashtable</code></strong>（支持快速范围查询和单键查找）。</li></ul></li><li><strong>用途</strong>：<ul><li>排行榜（按分数排序）。</li><li>范围查询（如时间区间内的数据）。</li></ul></li><li><strong>示例命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZADD leaderboard 100 <span class="hljs-string">&quot;user1&quot;</span><br>ZRANGE leaderboard 0 10 WITHSCORES<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-高级数据结构"><a href="#6-高级数据结构" class="headerlink" title="6. 高级数据结构"></a><strong>6. 高级数据结构</strong></h2><h3 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a><strong>6.1 Bitmaps</strong></h3><ul><li><strong>本质</strong>：基于 String 的位操作。</li><li><strong>用途</strong>：<ul><li>布尔统计（如用户每日签到）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">SETBIT sign:user:2023 10 1  <span class="hljs-comment"># 记录第10天签到</span><br>BITCOUNT sign:user:2023     <span class="hljs-comment"># 统计总签到次数</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a><strong>6.2 HyperLogLog</strong></h3><ul><li><strong>用途</strong>：基数统计（如 UV 统计，误差约 0.81%）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PFADD uv:2023 <span class="hljs-string">&quot;user1&quot;</span><br>PFCOUNT uv:2023<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-3-Geospatial（地理空间）"><a href="#6-3-Geospatial（地理空间）" class="headerlink" title="6.3 Geospatial（地理空间）"></a><strong>6.3 Geospatial（地理空间）</strong></h3><ul><li><strong>底层实现</strong>：基于 Sorted Set 的 GeoHash 编码。</li><li><strong>用途</strong>：地理位置查询（如附近的人）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">GEOADD cities 116.40 39.90 <span class="hljs-string">&quot;Beijing&quot;</span><br>GEORADIUS cities 116 39 100 km<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-4-Stream"><a href="#6-4-Stream" class="headerlink" title="6.4 Stream"></a><strong>6.4 Stream</strong></h3><ul><li><strong>用途</strong>：消息队列（支持消费者组、消息持久化）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">XADD mystream * field1 value1<br>XREAD COUNT 10 STREAMS mystream 0<br></code></pre></td></tr></table></figure></li></ul><h2 id="7-底层优化机制"><a href="#7-底层优化机制" class="headerlink" title="7. 底层优化机制"></a><strong>7. 底层优化机制</strong></h2><ul><li><strong>编码转换</strong>：根据数据规模和类型自动切换底层结构（如 Hash 从 <code>ziplist</code> 转 <code>hashtable</code>）。</li><li><strong>内存效率</strong>：优先使用紧凑结构（如 <code>ziplist</code>）减少碎片。</li></ul><h2 id="选择数据结构的建议"><a href="#选择数据结构的建议" class="headerlink" title="选择数据结构的建议"></a><strong>选择数据结构的建议</strong></h2><ol><li><strong>高频更新</strong>：优先选择时间复杂度低的结构（如 Hash 代替多个 String）。</li><li><strong>范围查询</strong>：使用 Sorted Set 或 List。</li><li><strong>去重统计</strong>：Set 或 HyperLogLog（根据精度需求）。</li></ol></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;Redis-数据结构及应用场景总结&quot;&gt;&lt;a href=&quot;#Redis-数据结构及应用场景总结&quot; class=&quot;headerlink&quot; title=&quot;Redis 数据结构及应用场景总结&quot;&gt;&lt;/a&gt;Redis</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="https://liuyuhe666.github.io/tags/Redis/"/>
    
    <category term="数据结构" scheme="https://liuyuhe666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UV 工具常用命令总结</title>
    <link href="https://liuyuhe666.github.io/2025/04/17/UV-%E5%B7%A5%E5%85%B7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://liuyuhe666.github.io/2025/04/17/UV-%E5%B7%A5%E5%85%B7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</id>
    <published>2025-04-17T11:47:11.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="UV-工具常用命令总结"><a href="#UV-工具常用命令总结" class="headerlink" title="UV 工具常用命令总结"></a>UV 工具常用命令总结</h1><p><code>uv</code> 是 <a href="https://github.com/astral-sh">Astral</a> 团队开发的一个 Python 包管理工具，目标是替代 <code>pip</code>, <code>virtualenv</code>, 和 <code>pip-tools</code> 等，提供更快更可靠的 Python 依赖管理体验。</p><p>GitHub 地址：<a href="https://github.com/astral-sh/uv">https://github.com/astral-sh/uv</a></p><h3 id="✅-常用命令总结"><a href="#✅-常用命令总结" class="headerlink" title="✅ 常用命令总结"></a>✅ 常用命令总结</h3><table><thead><tr><th>命令</th><th>功能简介</th></tr></thead><tbody><tr><td><code>uv venv</code></td><td>创建虚拟环境（替代 <code>python -m venv</code>）</td></tr><tr><td><code>uv pip</code></td><td>兼容 <code>pip</code> 子命令，几乎可以用作 <code>pip</code> 的替代</td></tr><tr><td><code>uv sync</code></td><td>安装 <code>pyproject.toml</code> 中的依赖（类似 <code>pip-sync</code> 或 <code>poetry install</code>）</td></tr><tr><td><code>uv pip install</code></td><td>安装依赖（类似 <code>pip install</code>）</td></tr><tr><td><code>uv pip freeze</code></td><td>输出当前环境的依赖（类似 <code>pip freeze</code>）</td></tr><tr><td><code>uv pip uninstall</code></td><td>卸载依赖</td></tr><tr><td><code>uv pip list</code></td><td>显示已安装的依赖列表</td></tr><tr><td><code>uv cache</code></td><td>管理缓存（查看&#x2F;清除缓存）</td></tr><tr><td><code>uv</code></td><td>显示所有子命令帮助信息</td></tr></tbody></table><h3 id="🔧-常见使用示例"><a href="#🔧-常见使用示例" class="headerlink" title="🔧 常见使用示例"></a>🔧 常见使用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建虚拟环境</span><br>uv venv .venv<br><br><span class="hljs-comment"># 激活虚拟环境（Linux/macOS）</span><br><span class="hljs-built_in">source</span> .venv/bin/activate<br><br><span class="hljs-comment"># 安装依赖（如 requests）</span><br>uv pip install requests<br><br><span class="hljs-comment"># 卸载依赖</span><br>uv pip uninstall requests<br><br><span class="hljs-comment"># 同步依赖（从 pyproject.toml 安装）</span><br>uv <span class="hljs-built_in">sync</span><br><br><span class="hljs-comment"># 导出依赖</span><br>uv pip freeze &gt; requirements.txt<br><br><span class="hljs-comment"># 查看依赖列表</span><br>uv pip list<br><br><span class="hljs-comment"># 清除缓存</span><br>uv cache clean<br><br><span class="hljs-comment"># 查看帮助</span><br>uv --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h3 id="⚡-特点"><a href="#⚡-特点" class="headerlink" title="⚡ 特点"></a>⚡ 特点</h3><ul><li>极快的依赖安装速度（使用 Rust 编写）</li><li>原生支持 <code>pyproject.toml</code></li><li>pip 兼容接口，无需重学命令</li><li>更少的网络请求和 IO 操作（有更智能的缓存策略）</li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;UV-工具常用命令总结&quot;&gt;&lt;a href=&quot;#UV-工具常用命令总结&quot; class=&quot;headerlink&quot; title=&quot;UV 工具常用命令总结&quot;&gt;&lt;/a&gt;UV</summary>
        
      
    
    
    
    
    <category term="Python" scheme="https://liuyuhe666.github.io/tags/Python/"/>
    
    <category term="uv" scheme="https://liuyuhe666.github.io/tags/uv/"/>
    
    <category term="包管理工具" scheme="https://liuyuhe666.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="https://liuyuhe666.github.io/2025/04/14/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://liuyuhe666.github.io/2025/04/14/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2025-04-14T18:55:13.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><blockquote><p>Git 是一个分布式版本控制以及源代码管理工具，它可以为你的项目保存若干快照，以此来对整个项目进行版本管理。</p></blockquote><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>初始化一个新的 Git 版本库，这个版本库的配置、存储等信息会被保存到当前目录的<code>.git</code> 文件夹中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init .<br></code></pre></td></tr></table></figure><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>修改 Git 配置，可以是版本库的配置，也可以是系统或全局配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出、设置基本的全局变量</span><br>git config --global user.email<br>git config --global user.name<br><br>git config --global user.email <span class="hljs-string">&quot;test@gmail.com&quot;</span><br>git config --global user.name <span class="hljs-string">&quot;Test&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-config">更多设置</a></p><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>Git 帮助文档，可以供我们快速查阅。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找可用命令</span><br>git <span class="hljs-built_in">help</span><br><br><span class="hljs-comment"># 查找所有可用命令</span><br>git <span class="hljs-built_in">help</span> -a<br><br><span class="hljs-comment"># 在文档当中查找特定的命令</span><br><span class="hljs-comment"># git help &lt;命令&gt;</span><br>git <span class="hljs-built_in">help</span> add<br>git <span class="hljs-built_in">help</span> commit<br>git <span class="hljs-built_in">help</span> init<br></code></pre></td></tr></table></figure><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>显示当前工作空间的状态信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示分支，未跟踪文件，更改和其他不同</span><br>git status<br><br><span class="hljs-comment"># 查看其他 git status 的用法</span><br>git <span class="hljs-built_in">help</span> status<br></code></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>添加文件到当前工作空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加一个文件</span><br>git add test.c<br><br><span class="hljs-comment"># 添加一个子目录中的文件</span><br>git add /path/to/file/test1.c<br><br><span class="hljs-comment"># 支持正则表达式</span><br>git add ./*.py<br></code></pre></td></tr></table></figure><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><p>管理分支，可以通过命令对分支进行增删改查。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有的分支和远程分支</span><br>git branch -a<br><br><span class="hljs-comment"># 创建一个新的分支</span><br>git branch myNewBranch<br><br><span class="hljs-comment"># 删除一个分支</span><br>git branch -d myBranch<br><br><span class="hljs-comment"># 重命名分支</span><br><span class="hljs-comment"># git branch -m &lt;旧名称&gt; &lt;新名称&gt;</span><br>git branch -m myBranchName myNewBranchName<br><br><span class="hljs-comment"># 编辑分支的介绍</span><br>git branch myBranchName --edit-description<br></code></pre></td></tr></table></figure><h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检出一个版本库，默认将更新到 master 分支</span><br>git checkout<br><span class="hljs-comment"># 检出到一个特定的分支</span><br>git checkout branchName<br><span class="hljs-comment"># 新建一个分支，并且切换过去，相当于&quot;git branch &lt;名字&gt;; git checkout &lt;名字&gt;&quot;</span><br>git checkout -b newBranch<br></code></pre></td></tr></table></figure><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆仓库</span><br>git <span class="hljs-built_in">clone</span> https://github.com/liuyuhe666/liuyuhe666.git<br></code></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提交时附带提交信息</span><br>git commit -m <span class="hljs-string">&quot;feat: add login&quot;</span><br></code></pre></td></tr></table></figure><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>显示当前工作区和提交的不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示工作目录和索引的不同</span><br>git diff<br><br><span class="hljs-comment"># 显示索引和最近一次提交的不同</span><br>git diff --cached<br><br><span class="hljs-comment"># 显示工作目录和最近一次提交的不同</span><br>git diff HEAD<br></code></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>在版本库中进行快速查找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在搜索结果中显示行号</span><br>git config --global grep.lineNumber <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 使得搜索结果可读性更好</span><br>git config --global alias.g <span class="hljs-string">&quot;grep --break --heading --line-number&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在所有的 java 文件中查找 variableName</span><br>git grep <span class="hljs-string">&#x27;variableName&#x27;</span> -- <span class="hljs-string">&#x27;*.java&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>显示版本库的提交日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示所有提交</span><br>git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 显示某几条提交信息</span><br>git <span class="hljs-built_in">log</span> -n 10<br><br><span class="hljs-comment"># 仅显示合并提交</span><br>git <span class="hljs-built_in">log</span> --merges<br></code></pre></td></tr></table></figure><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>合并分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将其他分支合并到当前分支</span><br>git merge branchName<br><br><span class="hljs-comment"># 在合并时创建一个新的合并后的提交</span><br>git merge --no-ff branchName<br></code></pre></td></tr></table></figure><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>重命名或移动一个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重命名</span><br>git <span class="hljs-built_in">mv</span> HelloWorld.c HelloNewWorld.c<br><br><span class="hljs-comment"># 移动</span><br>git <span class="hljs-built_in">mv</span> HelloWorld.c ./new/path/HelloWorld.c<br><br><span class="hljs-comment"># 强制重命名或移动</span><br><span class="hljs-comment"># 这个文件已经存在，将要覆盖掉</span><br>git <span class="hljs-built_in">mv</span> -f myFile existingFile<br></code></pre></td></tr></table></figure><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>从远程库中拉取代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从远端 origin 的 main 分支更新版本库</span><br><span class="hljs-comment"># git pull &lt;远端&gt; &lt;分支&gt;</span><br>git pull origin main<br></code></pre></td></tr></table></figure><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把本地的分支更新到远端 origin 的 main 分支上</span><br><span class="hljs-comment"># git push &lt;远端&gt; &lt;分支&gt;</span><br><span class="hljs-comment"># git push 相当于 git push origin main</span><br>git push origin main<br></code></pre></td></tr></table></figure><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将 newBranch 应用到 main 上面</span><br><span class="hljs-comment"># git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</span><br>git rebase main newBranch<br></code></pre></td></tr></table></figure><p><a href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing">详细介绍</a></p><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使暂存区域恢复到上次提交时的状态，不改变现在的工作目录</span><br>git reset<br><br><span class="hljs-comment"># 使暂存区域恢复到上次提交时的状态，覆盖现在的工作目录</span><br>git reset --hard<br><br><span class="hljs-comment"># 将当前分支恢复到某次提交，不改变现在的工作目录</span><br><span class="hljs-comment"># 在工作目录中所有的改变仍然存在</span><br>git reset 31f2bb1<br><br><span class="hljs-comment"># 将当前分支恢复到某次提交，覆盖现在的工作目录</span><br><span class="hljs-comment"># 并且删除所有未提交的改变和指定提交之后的所有提交</span><br>git reset --hard 31f2bb1<br></code></pre></td></tr></table></figure><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除 HelloWorld.c</span><br>git <span class="hljs-built_in">rm</span> HelloWorld.c<br><br><span class="hljs-comment"># 移除子目录中的文件</span><br>git <span class="hljs-built_in">rm</span> /pather/to/the/file/HelloWorld.c<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://git-scm.com/doc">https://git-scm.com/doc</a></li><li><a href="https://github.com/">https://github.com</a></li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;Git-常用命令&quot;&gt;&lt;a href=&quot;#Git-常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git 常用命令&quot;&gt;&lt;/a&gt;Git 常用命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Git</summary>
        
      
    
    
    
    
    <category term="Git" scheme="https://liuyuhe666.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>费曼学习法</title>
    <link href="https://liuyuhe666.github.io/2025/04/08/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <id>https://liuyuhe666.github.io/2025/04/08/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</id>
    <published>2025-04-08T18:04:41.000Z</published>
    <updated>2025-10-31T13:25:24.344Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h1><p>费曼学习法（Feynman Technique）是以诺贝尔物理学奖得主<strong>理查德·费曼</strong>（Richard Feynman）命名的一种高效学习方法，核心是通过**“以教促学”**的方式简化复杂概念，确保真正理解知识。</p><p>费曼认为：“如果你不能向一个六岁的孩子解释清楚某个概念，那么你自己也没有真正理解它。”</p><h2 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a><strong>核心步骤</strong></h2><ol><li><p><strong>选择概念</strong><br>确定要学习的目标概念或知识点，写在纸上。</p></li><li><p><strong>教授给孩子</strong><br>用最简单的语言向一个“假想的儿童”解释这个概念，避免使用专业术语，强迫自己用类比、生活化的例子说明。<br>→ <strong>关键点</strong>：如果卡壳或解释不清，说明存在知识漏洞。</p></li><li><p><strong>发现漏洞，回归学习</strong><br>针对解释中模糊或卡壳的部分，重新查阅资料、补充学习，直到能用通俗语言流畅表达。</p></li><li><p><strong>简化与类比</strong><br>用更直观的比喻或图表进一步简化描述，确保逻辑清晰、无术语依赖。</p></li></ol><h2 id="为什么有效？"><a href="#为什么有效？" class="headerlink" title="为什么有效？"></a><strong>为什么有效？</strong></h2><ul><li><strong>暴露盲区</strong>：通过“教学”强迫大脑主动检索知识，暴露理解薄弱点。 </li><li><strong>化繁为简</strong>：避免机械记忆，强调本质理解。 </li><li><strong>主动学习</strong>：比被动阅读或听讲的效率更高（据研究，主动回忆的学习留存率可达90%）。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><ul><li>学习数理化等抽象概念  </li><li>准备考试或面试  </li><li>掌握新技能（如编程、语言）  </li><li>写作或表达训练（清晰传递观点）</li></ul><h2 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a><strong>举个栗子🌰</strong></h2><p><strong>概念</strong>：光合作用<br><strong>费曼式解释</strong>：<br>“植物像一个小工厂，它的‘食物’是阳光、空气和水。工厂的‘工人’（叶绿素）用阳光的能量，把空气里的二氧化碳和水变成糖（植物吃的饭），同时放出我们呼吸的氧气。” </p><p>如果解释时发现说不清“叶绿素的作用”，就需要回头补课。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>费曼学习法的本质是<strong>用输出倒逼输入</strong>，适合任何需要深度理解的领域。</p><p>它的魅力在于：<strong>真正的理解，一定可以用朴素的语言表达</strong>。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;费曼学习法&quot;&gt;&lt;a href=&quot;#费曼学习法&quot; class=&quot;headerlink&quot; title=&quot;费曼学习法&quot;&gt;&lt;/a&gt;费曼学习法&lt;/h1&gt;&lt;p&gt;费曼学习法（Feynman</summary>
        
      
    
    
    
    
    <category term="学习方法" scheme="https://liuyuhe666.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    <category term="面试" scheme="https://liuyuhe666.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList 扩容机制分析</title>
    <link href="https://liuyuhe666.github.io/2025/03/03/ArrayList-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>https://liuyuhe666.github.io/2025/03/03/ArrayList-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</id>
    <published>2025-03-03T20:56:22.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="ArrayList-扩容机制分析"><a href="#ArrayList-扩容机制分析" class="headerlink" title="ArrayList 扩容机制分析"></a>ArrayList 扩容机制分析</h1><blockquote><p>注意：文章内容基于 JDK 8，其他版本的 JDK 可能会存在差异。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    Object[] a = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = a.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c.getClass() == ArrayList.class) &#123;<br>            elementData = a;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            elementData = Arrays.copyOf(a, size, Object[].class);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><p>默认无参构造函数，初始化容量为 10，初始化为空数组，当添加第一个元素时，数组的容量才变成 10。</p><p>带容量参数的构造函数，用户可以在初始化 ArrayList 对象时，指定初始化容量大小，如果传入的参数大于0，则创建指定大小的数组，如果传入的参数等于 0，则初始化为空数组，如果传入的参数小于 0，则抛出异常。</p><h2 id="add-函数"><a href="#add-函数" class="headerlink" title="add 函数"></a>add 函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 确保数组容量符合要求</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果是默认容量，则返回默认容量和最小容量的较大者</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// 判断是否需要对数组进行扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="grow-函数"><a href="#grow-函数" class="headerlink" title="grow 函数"></a>grow 函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span><br><span class="hljs-comment">// 扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></p><p>新的容量为原来容量的 1.5 倍左右，如果新的容量小于最小需要的容量，则新的容量为最小需要的容量，如果新的容量大于<code>MAX_ARRAY_SIZE</code>，则调用<code>hugeCapacity</code>函数。</p><h2 id="hugeCapacity-函数"><a href="#hugeCapacity-函数" class="headerlink" title="hugeCapacity 函数"></a>hugeCapacity 函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ArrayList 的底层是数组，相当于动态数组，和 Java 中的数组相比，它的容量可以动态增长，每次扩容时新的容量为原来容量的 1.5 倍左右。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;ArrayList-扩容机制分析&quot;&gt;&lt;a href=&quot;#ArrayList-扩容机制分析&quot; class=&quot;headerlink&quot; title=&quot;ArrayList</summary>
        
      
    
    
    
    
    <category term="Java" scheme="https://liuyuhe666.github.io/tags/Java/"/>
    
    <category term="源码分析" scheme="https://liuyuhe666.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂：什么是SSR、SSG、CSR？</title>
    <link href="https://liuyuhe666.github.io/2025/02/09/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFSSR%E3%80%81SSG%E3%80%81CSR%EF%BC%9F/"/>
    <id>https://liuyuhe666.github.io/2025/02/09/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFSSR%E3%80%81SSG%E3%80%81CSR%EF%BC%9F/</id>
    <published>2025-02-09T16:53:22.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="一文搞懂：什么是SSR、SSG、CSR？"><a href="#一文搞懂：什么是SSR、SSG、CSR？" class="headerlink" title="一文搞懂：什么是SSR、SSG、CSR？"></a>一文搞懂：什么是SSR、SSG、CSR？</h1><p>SSR、SSG 和 CSR 是前端渲染中的三种常见技术，它们各自代表着不同的数据获取和页面渲染方式。了解这三者的区别和适用场景，对开发高效的 Web 应用非常重要。接下来我们逐一解析这三种技术：</p><h2 id="SSR（Server-Side-Rendering，服务器端渲染）"><a href="#SSR（Server-Side-Rendering，服务器端渲染）" class="headerlink" title="SSR（Server-Side Rendering，服务器端渲染）"></a><strong>SSR（Server-Side Rendering，服务器端渲染）</strong></h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>SSR 是指在服务器上生成 HTML 页面，然后将其发送到客户端（浏览器）。简单来说，用户访问页面时，服务器会直接生成并返回完整的 HTML，浏览器只需展示这些内容。这样做的好处是页面在用户访问时能够更快地显示出来，尤其是对于 SEO（搜索引擎优化）和首次加载性能非常友好。</p><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ul><li>用户发起请求。</li><li>服务器根据请求，动态生成 HTML 内容。</li><li>服务器返回 HTML 页面给客户端。</li><li>客户端接收并渲染页面。</li></ul><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul><li>优点：<ul><li>更好的 SEO，因为搜索引擎爬虫可以直接抓取 HTML 内容。</li><li>首屏加载更快，用户可以更早看到页面内容。</li></ul></li><li>缺点：<ul><li>服务器压力大，尤其是流量较高时，每次用户请求都需要重新渲染页面。</li><li>页面交互性能较低，因为页面完全由服务器渲染，客户端要等待 JavaScript 加载和执行后才会有交互。</li></ul></li></ul><h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><ul><li>适用于 SEO 要求高的场景，如博客、新闻网站等。</li><li>用户首次访问页面时对渲染速度要求较高。</li></ul><h2 id="SSG（Static-Site-Generation，静态站点生成）"><a href="#SSG（Static-Site-Generation，静态站点生成）" class="headerlink" title="SSG（Static Site Generation，静态站点生成）"></a><strong>SSG（Static Site Generation，静态站点生成）</strong></h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>SSG 是一种在构建时就将页面生成好（静态化），然后通过 CDN 或静态服务器提供给客户端的渲染方式。与 SSR 不同，SSG 并不依赖于每个用户请求时动态生成 HTML 页面，而是在构建时就已经将所有的 HTML 文件生成好，客户端只需加载已生成的静态页面。</p><h3 id="流程：-1"><a href="#流程：-1" class="headerlink" title="流程："></a>流程：</h3><ul><li>在构建时（通常是项目的构建过程中），生成所有页面的静态 HTML。</li><li>这些静态页面会被托管到 CDN 或静态文件服务器。</li><li>用户访问时，直接从 CDN 或静态服务器获取并渲染页面。</li></ul><h3 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h3><ul><li>优点：<ul><li>非常高效，因为所有的页面都是静态的，不需要依赖服务器来渲染。</li><li>几乎没有服务器负担，适合高并发的场景。</li><li>更快的页面加载，因为可以通过 CDN 提供快速访问。</li></ul></li><li>缺点：<ul><li>适用于内容更新较少的场景。内容需要频繁更新的网站可能不适合使用 SSG，因为每次更新都需要重新构建和部署。</li><li>不适用于高度动态的数据展示。</li></ul></li></ul><h3 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h3><ul><li>博客、文档、营销网站等内容相对静态的站点。</li><li>对 SEO 有较高要求，且页面内容不需要实时更新的场景。</li></ul><h2 id="CSR（Client-Side-Rendering，客户端渲染）"><a href="#CSR（Client-Side-Rendering，客户端渲染）" class="headerlink" title="CSR（Client-Side Rendering，客户端渲染）"></a><strong>CSR（Client-Side Rendering，客户端渲染）</strong></h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>CSR 是指浏览器在客户端通过 JavaScript 来渲染页面。服务器返回的是一个空的 HTML 框架，JavaScript 在浏览器中执行，通过接口获取数据，然后渲染页面。也就是页面内容由客户端动态生成。</p><h3 id="流程：-2"><a href="#流程：-2" class="headerlink" title="流程："></a>流程：</h3><ul><li>用户发起请求，服务器返回一个包含 JavaScript 代码的空 HTML 页面。</li><li>浏览器加载并执行 JavaScript，向 API 请求数据。</li><li>接收数据后，浏览器动态渲染页面。</li></ul><h3 id="优缺点：-2"><a href="#优缺点：-2" class="headerlink" title="优缺点："></a>优缺点：</h3><ul><li>优点：<ul><li>高度的交互性，适合开发单页应用（SPA）。</li><li>服务器负担较轻，页面渲染逻辑全部由客户端承担。</li><li>页面交互响应速度快，用户体验较好。</li></ul></li><li>缺点：<ul><li>首次加载时间较长，因为浏览器需要加载 JavaScript 文件、获取数据并渲染页面。</li><li>SEO 不友好，搜索引擎爬虫可能无法正确抓取页面内容，除非做额外的配置（例如服务器端渲染或使用预渲染技术）。</li><li>对浏览器性能要求较高，低性能设备可能加载慢。</li></ul></li></ul><h3 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h3><ul><li>适合单页应用（SPA）或数据动态变化较多的应用。</li><li>不太关注 SEO，更多注重用户体验和交互性的场景。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>SSR</strong>：服务器端渲染，适合需要 SEO 和快速首次加载的应用，但服务器负担较重。</li><li><strong>SSG</strong>：静态站点生成，适合内容不常变化、需要极高性能的站点，服务器负担小，CDN 提供极速访问。</li><li><strong>CSR</strong>：客户端渲染，适合需要丰富交互的单页应用，服务器负担轻，但首次加载慢，SEO 可能不理想。</li></ul><p>在实际开发中，选择哪种渲染方式要根据项目的具体需求来决定，甚至有些框架（如 Next.js）允许你混合使用这些渲染方式，以达到最佳的性能和用户体验。</p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;一文搞懂：什么是SSR、SSG、CSR？&quot;&gt;&lt;a href=&quot;#一文搞懂：什么是SSR、SSG、CSR？&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="前端" scheme="https://liuyuhe666.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>LC1195.交替打印字符串</title>
    <link href="https://liuyuhe666.github.io/2025/02/08/LC1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://liuyuhe666.github.io/2025/02/08/LC1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2025-02-08T11:22:34.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="1195-交替打印字符串"><a href="#1195-交替打印字符串" class="headerlink" title="1195. 交替打印字符串"></a><a href="https://leetcode.cn/problems/fizz-buzz-multithreaded/">1195. 交替打印字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p><ul><li>如果这个数字可以被 3 整除，输出 “fizz”。</li><li>如果这个数字可以被 5 整除，输出 “buzz”。</li><li>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。</li></ul><p>例如，当 <code>n = 15</code>，输出： <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>。</p><p>假设有这么一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FizzBuzz</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title class_">FizzBuzz</span>(int n) &#123; ... &#125;               <span class="hljs-comment">// constructor</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fizz</span>(<span class="hljs-params">printFizz</span>) &#123; ... &#125;          <span class="hljs-comment">// only output &quot;fizz&quot;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">buzz</span>(<span class="hljs-params">printBuzz</span>) &#123; ... &#125;          <span class="hljs-comment">// only output &quot;buzz&quot;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fizzbuzz</span>(<span class="hljs-params">printFizzBuzz</span>) &#123; ... &#125;  <span class="hljs-comment">// only output &quot;fizzbuzz&quot;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">number</span>(<span class="hljs-params">printNumber</span>) &#123; ... &#125;      <span class="hljs-comment">// only output the numbers</span><br>&#125;<br></code></pre></td></tr></table></figure><p>请你实现一个有四个线程的多线程版 <code>FizzBuzz</code>， 同一个 <code>FizzBuzz</code> 实例会被如下四个线程使用：</p><ol><li>线程A将调用 <code>fizz()</code> 来判断是否能被 3 整除，如果可以，则输出 <code>fizz</code>。</li><li>线程B将调用 <code>buzz()</code> 来判断是否能被 5 整除，如果可以，则输出 <code>buzz</code>。</li><li>线程C将调用 <code>fizzbuzz()</code> 来判断是否同时能被 3 和 5 整除，如果可以，则输出 <code>fizzbuzz</code>。</li><li>线程D将调用 <code>number()</code> 来实现输出既不能被 3 整除也不能被 5 整除的数字。</li></ol><p><strong>提示：</strong></p><ul><li>本题已经提供了打印字符串的相关方法，如 <code>printFizz()</code> 等，具体方法名请参考答题模板中的注释部分。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><code>synchronized</code> 可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p><p><code>currentNumber</code>表示当前的数字，在每个方法的循环中要确保 <code>currentNumber &lt;= n</code></p><ul><li>fizz：当<code>currentNumber % 3 == 0 &amp;&amp; currentNumber % 5 != 0</code>满足时执行，其他情况等待</li><li>buzz：当<code>currentNumber % 3 != 0 &amp;&amp; currentNumber % 5 == 0</code>满足时执行，其他情况等待</li><li>fizzbuzz：当<code>currentNumber % 3 == 0 &amp;&amp; currentNumber % 5 == 0</code>满足时执行，其他情况等待</li><li>number：当<code>currentNumber % 3 != 0 &amp;&amp; currentNumber % 5 != 0</code>满足时执行，其他情况等待</li></ul><p>由于 <code>currentNumber</code> 被多个线程共享，因此需要用锁来保证数据的一致性。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FizzBuzz</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> currentNumber;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FizzBuzz</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.currentNumber = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// printFizz.run() outputs &quot;fizz&quot;.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fizz</span><span class="hljs-params">(Runnable printFizz)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (currentNumber &lt;= n) &#123;<br>                <span class="hljs-keyword">if</span> (currentNumber % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; currentNumber % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>) &#123;<br>                    currentNumber++;<br>                    printFizz.run();<br>                    lock.notifyAll();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    lock.wait();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// printBuzz.run() outputs &quot;buzz&quot;.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buzz</span><span class="hljs-params">(Runnable printBuzz)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>         <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (currentNumber &lt;= n) &#123;<br>                <span class="hljs-keyword">if</span> (currentNumber % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> &amp;&amp; currentNumber % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;<br>                    currentNumber++;<br>                    printBuzz.run();<br>                    lock.notifyAll();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    lock.wait();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// printFizzBuzz.run() outputs &quot;fizzbuzz&quot;.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fizzbuzz</span><span class="hljs-params">(Runnable printFizzBuzz)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>         <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (currentNumber &lt;= n) &#123;<br>                <span class="hljs-keyword">if</span> (currentNumber % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; currentNumber % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>                    currentNumber++;<br>                    printFizzBuzz.run();<br>                    lock.notifyAll();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    lock.wait();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">number</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>         <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (currentNumber &lt;= n) &#123;<br>                <span class="hljs-keyword">if</span> (currentNumber % <span class="hljs-number">3</span> != <span class="hljs-number">0</span> &amp;&amp; currentNumber % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>) &#123;<br>                    printNumber.accept(currentNumber);<br>                    currentNumber++;<br>                    lock.notifyAll();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    lock.wait();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;1195-交替打印字符串&quot;&gt;&lt;a href=&quot;#1195-交替打印字符串&quot; class=&quot;headerlink&quot; title=&quot;1195. 交替打印字符串&quot;&gt;&lt;/a&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="LeetCode" scheme="https://liuyuhe666.github.io/tags/LeetCode/"/>
    
    <category term="多线程" scheme="https://liuyuhe666.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LC1117.H2O 生成</title>
    <link href="https://liuyuhe666.github.io/2025/01/20/LC1117-H2O-%E7%94%9F%E6%88%90/"/>
    <id>https://liuyuhe666.github.io/2025/01/20/LC1117-H2O-%E7%94%9F%E6%88%90/</id>
    <published>2025-01-20T12:04:06.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="1117-H2O-生成"><a href="#1117-H2O-生成" class="headerlink" title="1117. H2O 生成"></a><a href="https://leetcode.cn/problems/building-h2o/">1117. H2O 生成</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在有两种线程，氧 <code>oxygen</code> 和氢 <code>hydrogen</code>，你的目标是组织这两种线程来产生水分子。</p><p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p><p>氢和氧线程会被分别给予 <code>releaseHydrogen</code> 和 <code>releaseOxygen</code> 方法来允许它们突破屏障。</p><p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p><p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p><p>换句话说:</p><ul><li>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。</li><li>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。</li></ul><p>书写满足这些限制条件的氢、氧线程同步代码。</p><p><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入<span class="hljs-punctuation">:</span> water <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;HOH&quot;</span><br>输出<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HHO&quot;</span><br>解释<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HOH&quot;</span> 和 <span class="hljs-string">&quot;OHH&quot;</span> 依然都是有效解。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入<span class="hljs-punctuation">:</span> water <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;OOHHHH&quot;</span><br>输出<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HHOHHO&quot;</span><br>解释<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HOHHHO&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;OHHHHO&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;HHOHOH&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;HOHHOH&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;OHHHOH&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;HHOOHH&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;HOHOHH&quot;</span> 和 <span class="hljs-string">&quot;OHHOHH&quot;</span> 依然都是有效解。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 * n == water.length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>water[i] == &#39;O&#39; or &#39;H&#39;</code></li><li>输入字符串 <code>water</code> 中的 ‘H’ 总数将会是 <code>2 * n</code> 。</li><li>输入字符串 <code>water</code> 中的 ‘O’ 总数将会是 <code>n</code> 。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Semaphore（信号量）：是一种用来保护一个或多个共享资源访问的计数器。</p><p>如果线程想要访问某个资源就必须先获得这个资源的信号量，当信号量内部计数器大于 0 时，获取该信号量会使计数器减一，当信号量的计数器为 0 时，获取该信号量会使线程等待直到该计数器大于 0。</p><ul><li><code>hSemaphore</code>：初始值为 2，确保不超过 2 个 <code>hydrogen</code> 可以执行。</li><li><code>oSemaphore</code>：初始值为 0，一个 <code>O</code> 对应两个 <code>H</code>，<code>oxygen</code> 执行前要确保有两个 <code>H</code>。</li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H2O</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">hSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">oSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">H2O</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hydrogen</span><span class="hljs-params">(Runnable releaseHydrogen)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>hSemaphore.acquire();<br>        <span class="hljs-comment">// releaseHydrogen.run() outputs &quot;H&quot;. Do not change or remove this line.</span><br>        releaseHydrogen.run();<br>        oSemaphore.release();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oxygen</span><span class="hljs-params">(Runnable releaseOxygen)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        oSemaphore.acquire(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// releaseOxygen.run() outputs &quot;O&quot;. Do not change or remove this line.</span><br>releaseOxygen.run();<br>        hSemaphore.release(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;1117-H2O-生成&quot;&gt;&lt;a href=&quot;#1117-H2O-生成&quot; class=&quot;headerlink&quot; title=&quot;1117. H2O 生成&quot;&gt;&lt;/a&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="LeetCode" scheme="https://liuyuhe666.github.io/tags/LeetCode/"/>
    
    <category term="多线程" scheme="https://liuyuhe666.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LC1116.打印零与奇偶数</title>
    <link href="https://liuyuhe666.github.io/2025/01/19/LC1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/"/>
    <id>https://liuyuhe666.github.io/2025/01/19/LC1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/</id>
    <published>2025-01-19T10:28:47.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="1116-打印零与奇偶数"><a href="#1116-打印零与奇偶数" class="headerlink" title="1116. 打印零与奇偶数"></a><a href="https://leetcode.cn/problems/print-zero-even-odd/">1116. 打印零与奇偶数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现有函数 <code>printNumber</code> 可以用一个整数参数调用，并输出该整数到控制台。</p><ul><li>例如，调用 <code>printNumber(7)</code> 将会输出 <code>7</code> 到控制台。</li></ul><p>给你类 <code>ZeroEvenOdd</code> 的一个实例，该类中有三个函数：<code>zero</code>、<code>even</code> 和 <code>odd</code> 。<code>ZeroEvenOdd</code> 的相同实例将会传递给三个不同线程：</p><ul><li>**线程 A：**调用 <code>zero()</code> ，只输出 <code>0</code></li><li>**线程 B：**调用 <code>even()</code> ，只输出偶数</li><li>**线程 C：**调用 <code>odd()</code> ，只输出奇数</li></ul><p>修改给出的类，以输出序列 <code>&quot;010203040506...&quot;</code> ，其中序列的长度必须为 <code>2n</code> 。</p><p>实现 <code>ZeroEvenOdd</code> 类：</p><ul><li><code>ZeroEvenOdd(int n)</code> 用数字 <code>n</code> 初始化对象，表示需要输出的数。</li><li><code>void zero(printNumber)</code> 调用 <code>printNumber</code> 以输出一个 0 。</li><li><code>void even(printNumber)</code> 调用<code>printNumber</code> 以输出偶数。</li><li><code>void odd(printNumber)</code> 调用 <code>printNumber</code> 以输出奇数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;0102&quot;</span><br>解释：三条线程异步执行，其中一个调用 zero()，另一个线程调用 <span class="hljs-built_in">even</span>()，最后一个线程调用<span class="hljs-built_in">odd</span>()。正确的输出为 <span class="hljs-string">&quot;0102&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-string">&quot;0102030405&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>zero、even 和 odd 之间是同步关系，可以使用信号量来解决。</p><ul><li>信号量 s1：zero 打印完成，初始值为 0</li><li>信号量 s2：odd 打印完成，初始值为 0</li><li>信号量 s3：even 打印完成，初始值为 0</li></ul><p>开始时，先打印数字零再打印其他数字，所以在构造函数中，要先释放 <code>s1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZeroEvenOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-built_in">this</span>.n = n;<br>  s1.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>zero</code> 函数中，打印数字零之前要先获取 <code>s1</code>，数字零打印完成后，要判断下一个数字是奇数还是偶数，奇数要释放 <code>s2</code>，偶数要释放 <code>s3</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">s1.acquire();<br>printNumber.accept(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 奇数</span><br>    s2.release();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 偶数</span><br>    s3.release();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>odd</code> 和 <code>even</code> 函数类似，打印数字之前，先尝试获取对应的信号量，打印完成后，释放 <code>s1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>    s3.acquire();<br>    printNumber.accept(i);<br>    s1.release();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>  s2.acquire();<br>  printNumber.accept(i);<br>  s1.release();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZeroEvenOdd</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZeroEvenOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        s1.release();<br>    &#125;<br><br>    <span class="hljs-comment">// printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">zero</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            s1.acquire();<br>            printNumber.accept(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 奇数</span><br>                s2.release();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 偶数</span><br>                s3.release();<br>            &#125;<br>        &#125;   <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">even</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                s3.acquire();<br>                printNumber.accept(i);<br>                s1.release();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">odd</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                s2.acquire();<br>                printNumber.accept(i);<br>                s1.release();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;1116-打印零与奇偶数&quot;&gt;&lt;a href=&quot;#1116-打印零与奇偶数&quot; class=&quot;headerlink&quot; title=&quot;1116. 打印零与奇偶数&quot;&gt;&lt;/a&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="LeetCode" scheme="https://liuyuhe666.github.io/tags/LeetCode/"/>
    
    <category term="多线程" scheme="https://liuyuhe666.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LC1115.交替打印 FooBar</title>
    <link href="https://liuyuhe666.github.io/2025/01/18/LC1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0-FooBar/"/>
    <id>https://liuyuhe666.github.io/2025/01/18/LC1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0-FooBar/</id>
    <published>2025-01-18T12:02:37.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="1115-交替打印-FooBar"><a href="#1115-交替打印-FooBar" class="headerlink" title="1115. 交替打印 FooBar"></a><a href="https://leetcode.cn/problems/print-foobar-alternately/">1115. 交替打印 FooBar</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">FooBar</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span>()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      print(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span>()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      print(<span class="hljs-string">&quot;bar&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个不同的线程将会共用一个 <code>FooBar</code> 实例：</p><ul><li>线程 A 将会调用 <code>foo()</code> 方法，而</li><li>线程 B 将会调用 <code>bar()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>&quot;foobar&quot;</code> 被输出 <code>n</code> 次。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;foobar&quot;</span><br>解释：这里有两个线程被异步启动。其中一个调用 <span class="hljs-built_in">foo</span>() 方法, 另一个调用 <span class="hljs-built_in">bar</span>() 方法，<span class="hljs-string">&quot;foobar&quot;</span> 将被输出一次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;foobarfoobar&quot;</span><br>解释：<span class="hljs-string">&quot;foobar&quot;</span> 将被输出两次。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>foo 和 bar 之间是同步关系，可以使用信号量来解决这个问题。</p><ul><li>信号量 s1：foo 已经完成，初始值为 0</li><li>信号量 s2：bar 已经完成，初始值为 0</li></ul><p>foo 执行前需要确保 bar 已经完成，同理 bar 执行前也要确保 foo 已经完成。</p><p>注意：开始时，假设 bar 已经完成，因此要在构造函数中，执行 <code>s2.release()</code>，否则会导致 foo 和 bar 相互等待，从而导致死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FooBar</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-built_in">this</span>.n = n;<br>    s2.release();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooBar</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FooBar</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        s2.release();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Runnable printFoo)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            s2.acquire();<br>            <span class="hljs-comment">// printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.</span><br>            printFoo.run();<br>            s1.release();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(Runnable printBar)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            s1.acquire();<br>            <span class="hljs-comment">// printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.</span><br>            printBar.run();<br>            s2.release();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;1115-交替打印-FooBar&quot;&gt;&lt;a href=&quot;#1115-交替打印-FooBar&quot; class=&quot;headerlink&quot; title=&quot;1115. 交替打印 FooBar&quot;&gt;&lt;/a&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="LeetCode" scheme="https://liuyuhe666.github.io/tags/LeetCode/"/>
    
    <category term="多线程" scheme="https://liuyuhe666.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LC1114.按序打印</title>
    <link href="https://liuyuhe666.github.io/2025/01/05/LC1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/"/>
    <id>https://liuyuhe666.github.io/2025/01/05/LC1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</id>
    <published>2025-01-05T15:28:48.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="1114-按序打印"><a href="#1114-按序打印" class="headerlink" title="1114. 按序打印"></a><a href="https://leetcode.cn/problems/print-in-order/">1114. 按序打印</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span>()</span> &#123; print(<span class="hljs-string">&quot;first&quot;</span>); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">second</span>()</span> &#123; print(<span class="hljs-string">&quot;second&quot;</span>); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">third</span>()</span> &#123; print(<span class="hljs-string">&quot;third&quot;</span>); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>三个不同的线程 A、B、C 将会共用一个 <code>Foo</code> 实例。</p><ul><li>线程 A 将会调用 <code>first()</code> 方法</li><li>线程 B 将会调用 <code>second()</code> 方法</li><li>线程 C 将会调用 <code>third()</code> 方法</li></ul><p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p><p><strong>提示：</strong></p><ul><li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li><li>你看到的输入格式主要是为了确保测试的全面性。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,2,3]</span><br>输出：<span class="hljs-string">&quot;firstsecondthird&quot;</span><br>解释：<br>有三个线程会被异步启动。输入 <span class="hljs-selector-attr">[1,2,3]</span> 表示线程 A 将会调用 <span class="hljs-built_in">first</span>() 方法，线程 B 将会调用 <span class="hljs-built_in">second</span>() 方法，线程 C 将会调用 <span class="hljs-built_in">third</span>() 方法。正确的输出是 <span class="hljs-string">&quot;firstsecondthird&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,3,2]</span><br>输出：<span class="hljs-string">&quot;firstsecondthird&quot;</span><br>解释：<br>输入 <span class="hljs-selector-attr">[1,3,2]</span> 表示线程 A 将会调用 <span class="hljs-built_in">first</span>() 方法，线程 B 将会调用 <span class="hljs-built_in">third</span>() 方法，线程 C 将会调用 <span class="hljs-built_in">second</span>() 方法。正确的输出是 <span class="hljs-string">&quot;firstsecondthird&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums</code> 是 <code>[1, 2, 3]</code> 的一组排列</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>任务一、任务二和任务三之间是同步关系。</p><p>任务二需要在任务一完成后执行，任务三需要在任务二完成后执行。</p><p>可以使用两个信号量来解决这个问题。</p><ul><li>firstDone: 表示任务一已经完成，初始值为 0</li><li>secondDone: 表示任务二已经完成，初始值为 0</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Job1 &#123;<br>执行任务一<br><span class="hljs-function"><span class="hljs-title">V</span><span class="hljs-params">(firstDone)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Job2 &#123;<br><span class="hljs-function"><span class="hljs-title">P</span><span class="hljs-params">(firstDone)</span></span><br>执行任务二<br><span class="hljs-function"><span class="hljs-title">V</span><span class="hljs-params">(secondDone)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Job3 &#123;<br><span class="hljs-function"><span class="hljs-title">P</span><span class="hljs-params">(secondDone)</span></span><br>执行任务三<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">firstDone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">secondDone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Foo</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(Runnable printFirst)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <br>        <span class="hljs-comment">// printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br>        printFirst.run();<br>        <span class="hljs-comment">// 第一个任务执行完成</span><br>        firstDone.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Runnable printSecond)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 等待第一个任务执行完成</span><br>        <span class="hljs-keyword">while</span> (firstDone.get() != <span class="hljs-number">1</span>) &#123;<br><br>        &#125;<br>        <span class="hljs-comment">// printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br>        printSecond.run();<br>        <span class="hljs-comment">// 第二个任务执行完成</span><br>        secondDone.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">(Runnable printThird)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 等待第二个任务执行完成</span><br>        <span class="hljs-keyword">while</span> (secondDone.get() != <span class="hljs-number">1</span>) &#123;<br><br>        &#125;<br>        <span class="hljs-comment">// printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br>        printThird.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;1114-按序打印&quot;&gt;&lt;a href=&quot;#1114-按序打印&quot; class=&quot;headerlink&quot; title=&quot;1114. 按序打印&quot;&gt;&lt;/a&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="LeetCode" scheme="https://liuyuhe666.github.io/tags/LeetCode/"/>
    
    <category term="多线程" scheme="https://liuyuhe666.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="https://liuyuhe666.github.io/2024/08/15/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://liuyuhe666.github.io/2024/08/15/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2024-08-15T09:08:06.000Z</published>
    <updated>2025-10-31T13:25:24.344Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h1 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h1><p>考点：</p><ul><li>各个排序算法的时间复杂度和空间复杂度的对比</li><li>各个排序算法的基本思想和排序流程</li><li>重点掌握快速排序、希尔排序和归并排序</li></ul><p>排序算法对比：</p><p><img src="https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202502100859669.png" alt="排序算法对比"></p><p>学习资源推荐：</p><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">常见排序算法的动画演示</a></li><li><a href="https://github.com/hustcc/JS-Sorting-Algorithm">一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。</a></li></ul><p><strong>关于时间复杂度：</strong></p><p>平方阶：插入排序、选择排序、冒泡排序</p><p>线性对数阶：快速排序、堆排序、归并排序</p><p>线性阶：基数排序、桶排序</p><p><strong>关于稳定性：</strong></p><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</p><p>不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p><p>总结：快速排序和希尔排序在排序速度上的表现比较优秀，而归并排序则稍微次之。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思想：遍历要排序的数组，每次遍历时，它都会比较相邻两个数组元素的大小，如果前者比后者大，则交换它们的位置。一次遍历后，最大的元素会出现在数组末尾，重复上述操作，直到整个数组有序为止。</p><p>时间复杂度：<code>O(N^2)</code></p><p>空间复杂度：<code>O(1)</code></p><p>稳定性：稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 冒泡排序</span><br>        bubbleSort(arr);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length; <span class="hljs-comment">// 数组长度</span><br>        <span class="hljs-type">boolean</span> flag; <span class="hljs-comment">// 标记</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-comment">// 前者大于后者，交换位置</span><br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = temp;<br>                    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 发生了交换，则设置标记为 true</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!flag) &#123;<br>                <span class="hljs-comment">// 如果没有发生交换，则说明数组已经有序</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想：选择一个基准，将要排序的元素以基准为界，划分为两个部分，其中一部分的元素都比另一个部分的小，然后，再对这两个部分的元素分别进行快速排序（递归），最终得到有序的序列。</p><p>时间复杂度：最坏<code>O(N^2)</code>，平均<code>O(NlogN)</code></p><p>空间复杂度：<code>O(logN)</code></p><p>稳定性：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 快速排序</span><br>        quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[left];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right;<br>            <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>                <span class="hljs-comment">// 从右向左找小于基准的元素</span><br>                <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;<br>                    j--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                    arr[i] = arr[j];<br>                &#125;<br>                <span class="hljs-comment">// 从左向右找大于基准的元素</span><br>                <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                    arr[j] = arr[i];<br>                &#125;<br>            &#125;<br>            arr[i] = pivot;<br>            quickSort(arr, left, i - <span class="hljs-number">1</span>);<br>            quickSort(arr, i + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基本思想：将待排序的数组看作是两个数组，一个有序数组，一个无序数组，每次从无序数组中选择第一个元素，插入到有序数组的合适位置，重复上述操作即可完成排序。</p><p>时间复杂度：<code>O(N^2)</code></p><p>空间复杂度：<code>O(1)</code></p><p>稳定性：稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 插入排序</span><br>        insertSort(arr);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j - <span class="hljs-number">1</span>];<br>                    arr[j - <span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>基本思想：分组插入排序，对于待排序的数组，取一个 gap ，将数组中的元素分成若干个子序列，对每个子序列进行插入排序，然后缩小 gap，当 gap &#x3D; 1 时，排序完成。</p><p>时间复杂度：<code>-</code></p><p>空间复杂度：<code>O(1)</code></p><p>稳定性：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShellSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 希尔排序</span><br>        shellSort(arr);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gap; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + gap; j &lt; n; j += gap) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j - gap;<br>                        <span class="hljs-keyword">while</span> (k &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[k] &gt; temp) &#123;<br>                            arr[k + gap] = arr[k];<br>                            k -= gap;<br>                        &#125;<br>                        arr[k + gap] = temp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>基本思想：从数组中找到最小的元素放到数组的起始位置，再从剩余的元素中找到最小的元素，放到已经排好序的数组末尾，重复上述流程，即可完成排序。</p><p>时间复杂度：<code>O(N^2)</code></p><p>空间复杂度：<code>O(1)</code></p><p>稳定性：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 选择排序</span><br>        selectSort(arr);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIndex != i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[minIndex];<br>                arr[minIndex] = arr[i];<br>                arr[i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>基本思想：堆排序是指利用堆这种数据结构设计的一种排序算法。</p><p>堆是一个近似完全二叉树的结构，分为最小堆和最大堆，最大堆通常被用来进行升序排序，而最小堆通常被用来进行降序排序。</p><p>时间复杂度：<code>O(NlogN)</code></p><p>空间复杂度：<code>O(1)</code></p><p>稳定性：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 堆排序</span><br>        heapSort(arr);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-comment">// 建立最大堆</span><br>        buildMaxHeap(arr, len);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            swap(arr, <span class="hljs-number">0</span>, i);<br>            len--;<br>            heapify(arr, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> len)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-type">double</span>) (len / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            heapify(arr, i, len);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;<br>            largest = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;<br>            largest = right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            swap(arr, i, largest);<br>            heapify(arr, largest, len);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基本思想：长度为1的数组是有序，以此为递归边界，将数组一分为二，对两个部分分别进行归并排序，排序完成后，再合并这两个部分即可得到有序序列。</p><p>时间复杂度：<code>O(NlogN)</code></p><p>空间复杂度：<code>O(N)</code></p><p>稳定性：稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 归并排序</span><br>        mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j]) &#123;<br>                temp[k++] = arr[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[k++] = arr[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            temp[k++] = arr[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            temp[k++] = arr[j++];<br>        &#125;<br>        System.arraycopy(temp, <span class="hljs-number">0</span>, arr, left, temp.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            mergeSort(arr, left, mid);<br>            mergeSort(arr, mid + <span class="hljs-number">1</span>, right);<br>            merge(arr, left, mid, right);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>基本思想：将数组中的元素映射为桶的下标，遍历数组，每读取到一个元素，就让对应的桶加一，最后把桶中的数据提取出来，再转换成有序数组。</p><p>时间复杂度：最好情况为<code>O(N + K)</code>，最坏情况为<code>O(N ^ 2)</code></p><p>空间复杂度：<code>O(N + K)</code>，N为数据规模，K为桶的个数</p><p>稳定性：稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 桶排序</span><br>        bucketSort(arr, <span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> maxN)</span> &#123;<br>        <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxN];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : arr) &#123;<br>            bucket[k]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; maxN; i++) &#123;<br>            <span class="hljs-keyword">while</span> (bucket[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                arr[j++] = i;<br>                bucket[i]--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基本思想：将整数按位数切割成不同的数字，然后按每个位数分别进行比较，从最低位开始依次进行排序，这样从最低位排序一直到最高位排序完成后，数组就变成了一个有序序列。</p><p>时间复杂度：<code>O(N x K)</code></p><p>空间复杂度：<code>O(N + K)</code></p><p>稳定性：稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.sort;<br><br><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RadixSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">53</span>, <span class="hljs-number">3</span>, <span class="hljs-number">542</span>, <span class="hljs-number">748</span>, <span class="hljs-number">14</span>, <span class="hljs-number">214</span>, <span class="hljs-number">154</span>, <span class="hljs-number">63</span>, <span class="hljs-number">616</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// 基数排序</span><br>        radixSort(arr);<br>        System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : arr) &#123;<br>            bucket[(j / r) % <span class="hljs-number">10</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; bucket.length; i++) &#123;<br>            bucket[i] += bucket[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            temp[bucket[(arr[i] / r) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = arr[i];<br>            bucket[(arr[i] / r) % <span class="hljs-number">10</span>]--;<br>        &#125;<br>        System.arraycopy(temp, <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, temp.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxValue</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; result) &#123;<br>                result = arr[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> getMaxValue(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; maxValue / r &gt; <span class="hljs-number">0</span>; r *= <span class="hljs-number">10</span>) &#123;<br>            radixSort(arr, r);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/hokky/p/8529042.html">https://www.cnblogs.com/hokky/p/8529042.html</a></li><li><a href="https://pdai.tech/md/algorithm/alg-sort-overview.html">https://pdai.tech/md/algorithm/alg-sort-overview.html</a></li><li><a href="https://sort.hust.cc/">https://sort.hust.cc</a></li></ul><p><img src="https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425608.png" alt="微信公众号"></p><p align="center">🎨 完整代码：<a href="https://github.com/liuyuhe666/sort">https://github.com/liuyuhe666/sort</a></p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h1 id=&quot;常见排序算法&quot;&gt;&lt;a href=&quot;#常见排序算法&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="算法" scheme="https://liuyuhe666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://liuyuhe666.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>GPG 密钥的导入与导出</title>
    <link href="https://liuyuhe666.github.io/2024/08/06/GPG-%E5%AF%86%E9%92%A5%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/"/>
    <id>https://liuyuhe666.github.io/2024/08/06/GPG-%E5%AF%86%E9%92%A5%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/</id>
    <published>2024-08-06T15:49:52.000Z</published>
    <updated>2025-10-31T13:25:24.342Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>如果有多台设备需求，使用同一个 <code>GPG Key </code>会免去许多不必要的麻烦。</p><h2 id="以文件的形式导出"><a href="#以文件的形式导出" class="headerlink" title="以文件的形式导出"></a>以文件的形式导出</h2><p>在终端中输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --output gpg_pub.gpg --<span class="hljs-built_in">export</span> &#123; key ID &#125;<br><br>gpg --armor --output gpg_sec.gpg --export-secret-key &#123; key ID &#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>这样你就在当前路径下得到了两个 <code>GPG </code>文件了，请妥善保管这两个文件。</p></blockquote><h2 id="从-GPG-文件中导入"><a href="#从-GPG-文件中导入" class="headerlink" title="从 GPG 文件中导入"></a>从 GPG 文件中导入</h2><p>如果你的手中有 <code>GPG </code>文件，那么导入也十分简单。在终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --import gpg_pub.gpg<br><br>gpg --allow-secret-key-import --import gpg_sec.gpg<br><br></code></pre></td></tr></table></figure><blockquote><p>注意：使用自己的文件名和路径</p></blockquote></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;如果有多台设备需求，使用同一个 &lt;code&gt;GPG Key &lt;/code&gt;会免去许多不必要的麻烦。&lt;/p&gt;
&lt;h2 id=&quot;以文件的形式导出&quot;&gt;&lt;a href=&quot;#以文件的形式导出&quot;</summary>
        
      
    
    
    
    
    <category term="GPG" scheme="https://liuyuhe666.github.io/tags/GPG/"/>
    
  </entry>
  
  <entry>
    <title>使用 ffmpeg 分离视频流和音频流</title>
    <link href="https://liuyuhe666.github.io/2024/04/11/%E4%BD%BF%E7%94%A8-ffmpeg-%E5%88%86%E7%A6%BB%E8%A7%86%E9%A2%91%E6%B5%81%E5%92%8C%E9%9F%B3%E9%A2%91%E6%B5%81/"/>
    <id>https://liuyuhe666.github.io/2024/04/11/%E4%BD%BF%E7%94%A8-ffmpeg-%E5%88%86%E7%A6%BB%E8%A7%86%E9%A2%91%E6%B5%81%E5%92%8C%E9%9F%B3%E9%A2%91%E6%B5%81/</id>
    <published>2024-04-11T15:42:34.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>视频中含有视频流和音频流，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。</p><h2 id="查看视频中的两个流"><a href="#查看视频中的两个流" class="headerlink" title="查看视频中的两个流"></a>查看视频中的两个流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i test.mp4<br></code></pre></td></tr></table></figure><p>使用参数 -vcodec copy -an 和 -acodec copy -vn 可以分离出 视频流 和 音频流</p><h2 id="分离视频"><a href="#分离视频" class="headerlink" title="分离视频"></a>分离视频</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i test.mp4 -vcodec copy -an output.mp4<br></code></pre></td></tr></table></figure><h2 id="分离音频"><a href="#分离音频" class="headerlink" title="分离音频"></a>分离音频</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i test.mp4 -acodec copy -vn output.aac<br></code></pre></td></tr></table></figure><h2 id="直接将视频转码为-mp3-格式"><a href="#直接将视频转码为-mp3-格式" class="headerlink" title="直接将视频转码为 mp3 格式"></a>直接将视频转码为 mp3 格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i test.mp4 output.mp3<br></code></pre></td></tr></table></figure></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;视频中含有视频流和音频流，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。&lt;/p&gt;
&lt;h2 id=&quot;查看视频中的两个流&quot;&gt;&lt;a href=&quot;#查看视频中的两个流&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="ffmpeg" scheme="https://liuyuhe666.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法</title>
    <link href="https://liuyuhe666.github.io/2023/09/14/markdown-%E8%AF%AD%E6%B3%95/"/>
    <id>https://liuyuhe666.github.io/2023/09/14/markdown-%E8%AF%AD%E6%B3%95/</id>
    <published>2023-09-14T15:19:02.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br><span class="hljs-section">#### 四级标题</span><br><span class="hljs-section">##### 五级标题</span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">image</span>](<span class="hljs-link">https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425608.png</span>)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425608.png" alt="image"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>有序列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> Item1<br><span class="hljs-bullet">2.</span> Item2<br><span class="hljs-bullet">3.</span> Item3<br></code></pre></td></tr></table></figure><ol><li>Item1</li><li>Item2</li><li>Item3</li></ol><p>无序列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Item<br><span class="hljs-bullet">-</span> Item<br><span class="hljs-bullet">-</span> Item<br></code></pre></td></tr></table></figure><ul><li>Item</li><li>Item</li><li>Item</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```python</span><br><span class="hljs-code">print(&#x27;hello, world!&#x27;)</span><br><span class="hljs-code">```</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello, world!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|   A   |   B   |<br>| :---: | :---: |<br>| test1 | test2 |<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">test1</td><td align="center">test2</td></tr></tbody></table><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>段前加上 <code>&gt;</code> 即为引用，支持嵌套</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 这是引用</span><br>&gt;&gt; 支持嵌套<br></code></pre></td></tr></table></figure><blockquote><p>这是引用</p><blockquote><p>支持嵌套</p></blockquote></blockquote><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">GitHub</span>](<span class="hljs-link">https://github.com</span>)<br></code></pre></td></tr></table></figure><p><a href="https://github.com/">GitHub</a></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜体*</span><br></code></pre></td></tr></table></figure><p><em>斜体</em></p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**粗体**</span><br></code></pre></td></tr></table></figure><p><strong>粗体</strong></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~这段文字被删除了~~<br></code></pre></td></tr></table></figure><p><del>这段文字被删除了</del></p><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><h3 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h3><p>依赖于：</p><ul><li><a href="https://www.npmjs.com/package/markdown-it-sup">markdown-it-sup</a></li><li><a href="https://www.npmjs.com/package/markdown-it-sub">markdown-it-sub</a></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">H~2~O<br>29^th^<br></code></pre></td></tr></table></figure><h3 id="高亮标记"><a href="#高亮标记" class="headerlink" title="高亮标记"></a>高亮标记</h3><p>依赖于：</p><ul><li><a href="https://www.npmjs.com/package/markdown-it-mark">markdown-it-mark</a></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">==highlight==<br></code></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>依赖于：</p><ul><li><a href="https://www.npmjs.com/package/markdown-it-footnote">markdown-it-footnote</a></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这里是一条脚注[^1]。<br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">我是脚注。</span><br></code></pre></td></tr></table></figure><h3 id="LaTeX-数学公式"><a href="#LaTeX-数学公式" class="headerlink" title="LaTeX 数学公式"></a>LaTeX 数学公式</h3><p>依赖于：</p><ul><li><a href="https://www.npmjs.com/package/@traptitech/markdown-it-katex">markdown-it-katex</a></li></ul><h3 id="Mermaid-流程图"><a href="#Mermaid-流程图" class="headerlink" title="Mermaid 流程图"></a>Mermaid 流程图</h3><ul><li><a href="https://mermaid.js.org/"><code>https://mermaid.js.org</code></a></li></ul><h3 id="Tag-插件"><a href="#Tag-插件" class="headerlink" title="Tag 插件"></a>Tag 插件</h3><p>具体语法见相应主题的文档</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6">Hexo Fluid 用户手册 - Tag 插件</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></li><li><a href="https://markdown.com.cn/">https://markdown.com.cn/</a></li></ul></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot;</summary>
        
      
    
    
    
    
    <category term="Markdown" scheme="https://liuyuhe666.github.io/tags/Markdown/"/>
    
    <category term="Fluid" scheme="https://liuyuhe666.github.io/tags/Fluid/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://liuyuhe666.github.io/2023/08/14/hello-world/"/>
    <id>https://liuyuhe666.github.io/2023/08/14/hello-world/</id>
    <published>2023-08-14T15:19:02.000Z</published>
    <updated>2025-10-31T13:25:24.343Z</updated>
    
    <content type="html"><![CDATA[<div id="readmore-container"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);var isEncrypt = document.getElementById('hexo-blog-encrypt');var allowMobile = false;if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {try {var plugin = new ReadmorePlugin();plugin.init({"type": "hexo","id": "readmore-container","name": "爱编程的阿彬","blogId": "90404-1002832395481-212","qrcode": "https://raw.githubusercontent.com/liuyuhe666/images/main/PicGo/202412061425785.jpg","keyword": "验证码","random": "1","height": "auto","expires": "365","lockToc": "yes","interval": "60","baseUrl": "","tocSelector": "#toc-body"});} catch(e) {console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);}}</script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div id=&quot;readmore-container&quot;&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a</summary>
        
      
    
    
    
    
    <category term="Hexo" scheme="https://liuyuhe666.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
